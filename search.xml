<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo Hello World</title>
    <url>/studyz.github.io/2019/05/01/2019_05_01_hello_world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Here-Cheatsheet">Markdown</a> 使用<a href="https://github.com/younghz/Markdown">Markdown 基本语法</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><hr>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo init [folder]</span></span><br></pre></td></tr></table></figure>

<p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p>
<p>本命令相当于执行了以下几步：</p>
<ol>
<li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li>
<li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.io/zh/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/zh-cn/docs/index.html#%E5%AE%89%E8%A3%85-Node-js">Node.js</a> 安装。</li>
</ol>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new post <span class="string">&quot;PostName&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line"><span class="comment"># 该命令可以简写为</span></span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo generate</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该命令可以简写为</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo g</span></span><br></pre></td></tr></table></figure>

<p>生成静态文件。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>-d</code>, <code>--deploy</code></td>
<td>文件生成后立即部署网站</td>
</tr>
<tr>
<td><code>-w</code>, <code>--watch</code></td>
<td>监视文件变动</td>
</tr>
<tr>
<td><code>-b</code>, <code>--bail</code></td>
<td>生成过程中如果发生任何未处理的异常则抛出异常</td>
</tr>
<tr>
<td><code>-f</code>, <code>--force</code></td>
<td>强制重新生成文件  <br>Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。  <br>使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td>
</tr>
<tr>
<td><code>-c</code>, <code>--concurrency</code></td>
<td>最大同时生成文件的数量，默认无限制</td>
</tr>
</tbody></table>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line"><span class="comment"># 该命令可以简写为</span></span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo version</span></span><br></pre></td></tr></table></figure>

<p>显示 Hexo 版本。</p>
<h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><hr>
<h3 id="本地图片的调用"><a href="#本地图片的调用" class="headerlink" title="本地图片的调用"></a>本地图片的调用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">my version</span></span><br><span class="line">hexo: 7.2.0</span><br><span class="line">hexo-cli: 4.3.2</span><br></pre></td></tr></table></figure>

<ol>
<li><p>手动新建<br>首先是在 _posts 文件夹下建立一个<code>本地图片的调用.md</code>，再建立一个同名的文件夹 <code>本地图片的调用</code>。</p>
</li>
<li><p>hexo代码新建<br>使用<code>hexo new post 本地图片的调用</code>，可以生成md文件的同时生成一个同名文件夹用于存储网页资源。</p>
</li>
</ol>
<p>这篇文章要引用的图片就放在该文件夹下。比如我就在该目录下放一个图片<code>1.png</code>。</p>
<p><img src="/studyz.github.io/2019/05/01/2019_05_01_hello_world/1.png" alt="1.png"></p>
<p>然后在博文 MarkDown 文件里引用该图片：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">这里是图片注释</span>](<span class="link">1.png</span>)</span><br></pre></td></tr></table></figure>

<p><strong>为什么引用的时候不用加文件夹的路径呢？</strong></p>
<p>这是因为 hexo 在渲染的时候，会把<code>本地图片的调用.md</code> 渲染为<code>public</code>下的 <code>本地图片的调用.html</code>网页文件，而把对应文件夹下的静态资源，比如图片 <code>1.png</code>也拷贝到<code>public</code>下!</p>
<p>需要注意的是，在<code>hexo/source/_posts</code>目录下的图片文件名不能重复。</p>
<h3 id="skip-render"><a href="#skip-render" class="headerlink" title="skip render"></a>skip render</h3><p>修改hexo根目录下_config.yml文件，</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">&#x27;_posts/templates/**&#x27;</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">&#x27;_posts/draft/**&#x27;</span></span><br></pre></td></tr></table></figure>

<p>目录结构：<br><code>- hexo/source/_posts/templates/</code> 保存post模版，供Obsidian快速开始Post编写。<br><code>- hexo/source/_posts/draft/</code> 保存未编辑完成，或不想共享的文章内容。</p>
<p>设置跳过渲染之后，最好使用<code>hexo clean</code>清除以前的编译结果，保证配置生效。再使用<code>hexo g</code>查看。</p>
<h3 id="自动generate"><a href="#自动generate" class="headerlink" title="自动generate"></a>自动generate</h3><p>定时or设置条件运行命令<code>docker exec -it hexo bash -c &quot;hexo clean &amp;&amp; hexo g&quot;</code>来自动编译。</p>
<p><strong>踩坑：</strong> 直接在群晖的<code>控制面板</code> - <code>任务计划</code>中添加自定义脚本<code>docker exec -it hexo bash -c &quot;hexo clean &amp;&amp; hexo g&quot;</code>会报错<code>the input device is not a TTY</code>.</p>
<p>tty一词源于Teletypes,或teletypewriters。这个的意思是说后台linux执行的时候没有终端设备。我们一般执行docker里的命令时候都喜欢加上-it 这个参数，这里的-t 就是表示伪tty。所以，如果我们docker执行后台运行的任务或者程序直接去除 -t 这个参数就不会出现这个报错了。</p>
<p><strong>所以要用 <code>docker exec hexo bash -c &quot;hexo clean &amp;&amp; hexo g&quot;</code></strong></p>
<p><strong>待改进：</strong> 设置了每天generate一次。如果设置成有变动就generate就更好了，暂时没想到办法。</p>
<h3 id="视频嵌入"><a href="#视频嵌入" class="headerlink" title="视频嵌入"></a>视频嵌入</h3><p>现在视频基本上都会分享到各大平台，所以暂时主要以嵌入网络视频展示。<br>研究了几款插件，基本上都是年久失修，使用不易，最终还是选择了<code>iframe</code>嵌入。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">%%bilibili视频嵌入%%</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=244387247&amp;cid=229573649&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; width: 100%; height: 100%; Left: 0; top: 0;&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/stephenmkbrady/hexo-tag-html5">hexo-tag-html5video</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-tag-html5video</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% html5video &#x27;100%&#x27; &#x27;250px&#x27; &#x27;video/mp4&#x27; %&#125; </span><br><span class="line">&#123;% asset<span class="emphasis">_path &lt;视频路径&gt; %&#125; </span></span><br><span class="line"><span class="emphasis">&#123;% endhtml5video %&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="菜单导航配置"><a href="#菜单导航配置" class="headerlink" title="菜单导航配置"></a>菜单导航配置</h3><p>配置基本菜单导航的名称、路径url和图标icon.</p>
<ol>
<li><p>菜单导航名称可以是中文也可以是英文(如：<code>Index</code> 或 <code>主页</code>)</p>
</li>
<li><p><code>External</code> 表示是否在新标签页打开连接</p>
</li>
<li><p>导航地址可以是站内地址也可以是外网地址</p>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line"></span><br><span class="line"><span class="code">	Index:</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">		url: /</span></span><br><span class="line"><span class="code">		</span></span><br><span class="line"><span class="code">		External: false</span></span><br><span class="line"><span class="code">		</span></span><br><span class="line"><span class="code">		name: 首页</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	Tags:</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">		url: /tags</span></span><br><span class="line"><span class="code">		</span></span><br><span class="line"><span class="code">		External: false</span></span><br><span class="line"><span class="code">		</span></span><br><span class="line"><span class="code">		name: 标签</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	# Categories:</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">		# url: /categories</span></span><br><span class="line"><span class="code">		</span></span><br><span class="line"><span class="code">		# External: false</span></span><br><span class="line"><span class="code">		</span></span><br><span class="line"><span class="code">		# name: 分类</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	Archives:</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">		url: /archives</span></span><br><span class="line"><span class="code">		</span></span><br><span class="line"><span class="code">		External: false</span></span><br><span class="line"><span class="code">		</span></span><br><span class="line"><span class="code">		name: 归档</span></span><br><span class="line"><span class="code">		</span></span><br><span class="line"><span class="code">	About:</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">		url: /about</span></span><br><span class="line"><span class="code">		</span></span><br><span class="line"><span class="code">		External: false</span></span><br><span class="line"><span class="code">		</span></span><br><span class="line"><span class="code">		name: 关于</span></span><br></pre></td></tr></table></figure>






<p>More info:<br><a href="https://post.smzdm.com/p/agqol9zm/">晨聊 篇十七：markdown也变脸，obsidian + hexo 在群晖NAS上的双剑合璧</a></p>
]]></content>
      <categories>
        <category>tutorial</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>hexo</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>鸡尾酒配方</title>
    <url>/studyz.github.io/2020/05/04/2020_05_04_%E9%B8%A1%E5%B0%BE%E9%85%92%E9%85%8D%E6%96%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="鸡尾酒配方"><a href="#鸡尾酒配方" class="headerlink" title="鸡尾酒配方"></a>鸡尾酒配方</h1><h2 id="茶酒"><a href="#茶酒" class="headerlink" title="茶酒"></a>茶酒</h2><ul>
<li>茶：120ml</li>
<li>酒：45ml</li>
<li>糖浆：10ml</li>
<li>柠檬：5ml</li>
</ul>
<h2 id="B52轰炸机"><a href="#B52轰炸机" class="headerlink" title="B52轰炸机"></a>B52轰炸机</h2><ul>
<li>1&#x2F;3咖啡力娇酒</li>
<li>1&#x2F;3百利甜</li>
<li>1&#x2F;3君度</li>
</ul>
<h2 id="长岛冰茶"><a href="#长岛冰茶" class="headerlink" title="长岛冰茶"></a>长岛冰茶</h2><ul>
<li>饮具：玻璃杯加冰</li>
<li>黄柠汁：5ml</li>
<li>伏特加：15ml</li>
<li>龙舌兰：15ml</li>
<li>金酒：15ml</li>
<li>白朗姆：15ml</li>
<li>可乐：填满</li>
<li>装饰</li>
</ul>
<h2 id="自由古巴"><a href="#自由古巴" class="headerlink" title="自由古巴"></a>自由古巴</h2><ul>
<li>绿柠：5ml</li>
<li>白朗姆：45ml</li>
<li>可乐：加满</li>
<li>装饰</li>
</ul>
<h2 id="莫吉托"><a href="#莫吉托" class="headerlink" title="莫吉托"></a>莫吉托</h2><ul>
<li>绿柠块：3块（挤压）</li>
<li>薄荷：轻挤压</li>
<li>薄荷糖浆：8ml</li>
<li>白朗姆：45ml</li>
<li>冰：满</li>
<li>苏打水：加到杯子4&#x2F;5</li>
<li>用勺子伸到杯底做提拉</li>
<li>装饰：绿柠片，薄荷簇</li>
</ul>
<h2 id="教父"><a href="#教父" class="headerlink" title="教父"></a>教父</h2><ul>
<li>饮具：传统杯 + 方冰</li>
<li>金宾波本：50ml</li>
<li>蒂萨诺：10ml</li>
<li>用勺子搅匀</li>
</ul>
<h2 id="蓝色夏威夷"><a href="#蓝色夏威夷" class="headerlink" title="蓝色夏威夷"></a>蓝色夏威夷</h2><ul>
<li>饮具：玻璃杯 + 冰</li>
<li>白朗姆：40ml</li>
<li>蓝橙：20ml</li>
<li>马利宝：20ml</li>
<li>菠萝汁：45ml</li>
<li>雪碧：加满</li>
<li>装饰</li>
</ul>
<h2 id="醉酒的梵高"><a href="#醉酒的梵高" class="headerlink" title="醉酒的梵高"></a>醉酒的梵高</h2><ul>
<li>龙舌兰：40ml</li>
<li>菠萝汁：45ml</li>
<li>雪碧：加满</li>
<li>蓝橙力娇：最后加入，不搅动</li>
</ul>
<h2 id="心橙大海"><a href="#心橙大海" class="headerlink" title="心橙大海"></a>心橙大海</h2><ul>
<li>饮具：玻璃杯 + 冰</li>
<li>伏特加：45ml</li>
<li>橙汁：装满</li>
</ul>
<h2 id="金汤力"><a href="#金汤力" class="headerlink" title="金汤力"></a>金汤力</h2><ul>
<li>饮具：玻璃杯 + 冰</li>
<li>金酒：45ml</li>
<li>汤力水：加满</li>
<li>装饰</li>
</ul>
<h2 id="日出"><a href="#日出" class="headerlink" title="日出"></a>日出</h2><ul>
<li>饮具：玻璃杯 + 冰</li>
<li>龙舌兰：45ml</li>
<li>橙汁：加满</li>
<li>红色糖浆：适量调整着色区域</li>
</ul>
<h2 id="蓝色玛格丽特"><a href="#蓝色玛格丽特" class="headerlink" title="蓝色玛格丽特"></a>蓝色玛格丽特</h2><ul>
<li>饮具：玻璃杯 + 盐边</li>
<li>龙舌兰：30ml</li>
<li>蓝橙力娇酒：15ml</li>
<li>蔗糖：5ml</li>
<li>黄柠檬：点缀</li>
</ul>
<h2 id="白色玛格丽特"><a href="#白色玛格丽特" class="headerlink" title="白色玛格丽特"></a>白色玛格丽特</h2><ul>
<li>龙舌兰：30ml</li>
<li>君度：15ml</li>
<li>柠檬汁：几滴</li>
<li>蔗糖：5ml</li>
<li>加冰块摇匀</li>
</ul>
<h2 id="威士忌酸"><a href="#威士忌酸" class="headerlink" title="威士忌酸"></a>威士忌酸</h2><ul>
<li>波本：45ml</li>
<li>黄柠檬：半个</li>
<li>蔗糖：10ml</li>
<li>加冰块摇匀</li>
</ul>
<h2 id="前任"><a href="#前任" class="headerlink" title="前任"></a>前任</h2><ul>
<li>饮具：玻璃杯 + 冰</li>
<li>龙舌兰：45ml</li>
<li>红柚糖浆：适量</li>
<li>苏打水：加满</li>
</ul>
<h2 id="孟婆汤"><a href="#孟婆汤" class="headerlink" title="孟婆汤"></a>孟婆汤</h2><ul>
<li>伏特加：30ml</li>
<li>柠檬汁：15ml</li>
<li>马力宝：15ml</li>
<li>莫林绿薄荷糖浆：10ml</li>
</ul>
<h2 id="百香果莫吉托（无酒精）"><a href="#百香果莫吉托（无酒精）" class="headerlink" title="百香果莫吉托（无酒精）"></a>百香果莫吉托（无酒精）</h2><ul>
<li>青柠汁：5ml</li>
<li>冰：加满</li>
<li>百香果糖浆：12ml</li>
<li>薄荷糖浆：12ml</li>
<li>气泡水：加满</li>
<li>搅匀装饰</li>
</ul>
<h2 id="波斯猫（无酒精）"><a href="#波斯猫（无酒精）" class="headerlink" title="波斯猫（无酒精）"></a>波斯猫（无酒精）</h2><ul>
<li>橙汁：60ml</li>
<li>菠萝汁：40ml</li>
<li>柠檬汁：半个</li>
<li>红石榴糖浆：2勺</li>
<li>蔗糖：1勺</li>
<li>加冰块摇匀</li>
</ul>
<h2 id="蓝色多瑙河（无酒精）"><a href="#蓝色多瑙河（无酒精）" class="headerlink" title="蓝色多瑙河（无酒精）"></a>蓝色多瑙河（无酒精）</h2><ul>
<li>柠檬汁：一点</li>
<li>蓝柑糖浆：10ml</li>
<li>蔗糖糖浆：5ml</li>
<li>苏打水</li>
</ul>
<h2 id="柚恋柠檬（无酒精）"><a href="#柚恋柠檬（无酒精）" class="headerlink" title="柚恋柠檬（无酒精）"></a>柚恋柠檬（无酒精）</h2><ul>
<li>柠檬汁：一点</li>
<li>红柚糖浆：10ml</li>
<li>蔗糖糖浆：5ml</li>
<li>苏打水</li>
</ul>
<h2 id="清凉一夏（无酒精）"><a href="#清凉一夏（无酒精）" class="headerlink" title="清凉一夏（无酒精）"></a>清凉一夏（无酒精）</h2><ul>
<li>饮具：威士忌杯🥃 + 方冰</li>
<li>新鲜薄荷叶：4-5 片，拍醒</li>
<li>可乐：加至8分满</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
        <category>鸡尾酒</category>
      </categories>
      <tags>
        <tag>鸡尾酒</tag>
        <tag>配方</tag>
      </tags>
  </entry>
  <entry>
    <title>GoPro Hero最实用的四个必备配件:打造完美生态</title>
    <url>/studyz.github.io/2022/03/15/2022_03_15_GoproHero/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<iframe src="//player.bilibili.com/player.html?aid=244387247&bvid=BV1Av411174q&cid=229573649&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div> 
]]></content>
      <categories>
        <category>数码</category>
        <category>相机</category>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>数码</tag>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title>菜谱</title>
    <url>/studyz.github.io/2020/02/19/2022_04_19_%E8%8F%9C%E8%B0%B1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="空气炸锅鸡排"><a href="#空气炸锅鸡排" class="headerlink" title="空气炸锅鸡排"></a>空气炸锅鸡排</h1><ul>
<li>温度：200度</li>
<li>时间：8分钟 + 4分钟</li>
</ul>
<h1 id="空气炸锅健身食品"><a href="#空气炸锅健身食品" class="headerlink" title="空气炸锅健身食品"></a>空气炸锅健身食品</h1><ul>
<li>鸡胸肉（黑胡椒、13香、橄榄油）</li>
<li>地瓜（切块、橄榄油）</li>
<li>温度：180度</li>
<li>时间：15分钟</li>
</ul>
<p><a href="https://www.youtube.com/watch?v=D8O7myqk0Bw">健身食品制作视频</a></p>
<h1 id="阳春面调料"><a href="#阳春面调料" class="headerlink" title="阳春面调料"></a>阳春面调料</h1><ul>
<li>生抽、陈醋、盐、香油或猪油、葱花</li>
</ul>
<h1 id="爆炒香辣鱿鱼"><a href="#爆炒香辣鱿鱼" class="headerlink" title="爆炒香辣鱿鱼"></a>爆炒香辣鱿鱼</h1><p>食材：</p>
<ul>
<li>鱿鱼须、葱、姜、洋葱、料酒、豆瓣酱、生抽、老抽、蚝油、白糖、盐、熟芝麻</li>
</ul>
<p>做法：</p>
<ol>
<li>鱿鱼洗净切好备用，冷水下锅，加入姜片、葱段、1勺料酒，焯水捞出备用</li>
<li>锅中油热，倒入洋葱丝，炒出香味，加入1勺豆瓣酱炒出红油，倒入焯好水的鱿鱼须，翻炒上色</li>
<li>加入1勺生抽、半勺老抽、1勺蚝油、适量白糖、少许盐、1勺熟芝麻，翻炒均匀，撒上葱花即可</li>
</ol>
]]></content>
      <categories>
        <category>生活</category>
        <category>菜谱</category>
      </categories>
      <tags>
        <tag>菜谱</tag>
        <tag>下酒菜</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas基本操作</title>
    <url>/studyz.github.io/2022/04/19/2023_03_15_Pandas%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看头部 head(n)</span></span><br><span class="line">df.head()  <span class="comment">#默认查看前5条记录 </span></span><br><span class="line">df.head(<span class="number">8</span>)  <span class="comment">#指定查看前8条记录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看尾部 tail(n)</span></span><br><span class="line">df.tail()  <span class="comment">#默认查看后面5条记录 </span></span><br><span class="line">df.tail(<span class="number">4</span>)  <span class="comment">#指定查看后面4条记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 随机查看样本 sample(n)</span></span><br><span class="line">df.sample()  <span class="comment">#随机查看一条记录 </span></span><br><span class="line">df.sample(<span class="number">4</span>)  <span class="comment">#随机查看4条记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看统计摘要</span></span><br><span class="line">df.describe()  <span class="comment">#返回所有数字列的统计摘要</span></span><br></pre></td></tr></table></figure>

<h1 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 切片[]</span></span><br><span class="line">df[<span class="number">0</span>:<span class="number">3</span>]  <span class="comment">#通过切片检索行数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## loc\iloc</span></span><br><span class="line">df.loc[<span class="number">1</span>]  <span class="comment">#标量标签，返回该行标签的Series数据 </span></span><br><span class="line">df.loc[[<span class="number">1</span>,<span class="number">3</span>]]  <span class="comment">#标签列表，返回标签列表的行DataFrame数据 </span></span><br><span class="line">df.loc[<span class="number">0</span>:<span class="number">3</span>]  <span class="comment">#切片对象，返回切片的行DataFrame数据 </span></span><br><span class="line">df.loc[<span class="number">0</span>:<span class="number">3</span>,<span class="string">&#x27;staff_id&#x27;</span>:<span class="string">&#x27;staff_salary&#x27;</span>]  <span class="comment">#根据行切片，列切片检索数据 </span></span><br><span class="line">df.loc[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="string">&#x27;staff_id&#x27;</span>,<span class="string">&#x27;staff_name&#x27;</span>,<span class="string">&#x27;staff_age&#x27;</span>]]  <span class="comment">#根据行标签列表，列标签列表检索数据</span></span><br><span class="line">df.iloc[<span class="number">1</span>]  <span class="comment">#整数标量选择，数据从0开始，为1的就是第二行的数据，返回的是Series </span></span><br><span class="line">df.iloc[[<span class="number">1</span>,<span class="number">3</span>]]  <span class="comment">#整数列表选择，选择位置为1和3的数据，返回的是DataFrame </span></span><br><span class="line">df.iloc[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment">#切片选择，选择位置1至2的数据，不包含边界结束值，也就是不包含3的位置 </span></span><br><span class="line">df.iloc[<span class="number">1</span>:<span class="number">3</span>,<span class="number">1</span>:<span class="number">4</span>]  <span class="comment">#切片选择位置为1至3的行和1至4的列不含位置为3的行和位置为4的列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## at\iat</span></span><br><span class="line">df.at[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;staff_name&#x27;</span>]  <span class="comment">#检索第“A”行的列标签为&quot;staff_name&quot;的数据 df.iat[0,1]  #检索第1行第2列的数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python一些文章</title>
    <url>/studyz.github.io/2022/04/23/2023_03_15_Python%E4%B8%80%E4%BA%9B%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pythontutor.com/">Visualize code in Python, JavaScript, C, C++, and Java: pythontutor</a><br><a href="https://visualgo.net/">visualising data structures and algorithms through animation:Python动画算法</a></p>
<hr>
<p><a href="https://www.programcreek.com/python">Python Code Examples: Python代码例子</a><br><a href="https://mp.weixin.qq.com/s/0b_bG83S-LEpQOtaWZXv3A">Python网站开发库大全整理完了</a><br><a href="https://mp.weixin.qq.com/s/5bYBrDs90JWMj1A25K4WkQ">14个VSCode插件，让你写代码如同神一般</a><br><a href="https://mp.weixin.qq.com/s/B1q3n--GrK9ybtUcw9eC-Q">Python中关于进度条的6个实用技巧</a><br><a href="https://mp.weixin.qq.com/s/lRicXgAoUYAYO_WpFdQo6A">45个Git经典操作场景，专治不会合代码</a><br><a href="https://mp.weixin.qq.com/s/9qtNkNs6qcJqqEFS15jw-w">进阶版的Pandas神器：Polars</a><br><a href="https://mp.weixin.qq.com/s/qbSoq05Aaw-YPmdbYrgUdg">Sklearn模块中不为人知又超级好用的API函数</a><br><a href="https://mp.weixin.qq.com/s/ndmIgNGN6eBsoF4Y1CeaFg">Python列表解析式到底该怎么用？</a><br><a href="https://mp.weixin.qq.com/s/ScoUXRyeJGo1g0LaiLoxSw">20个短小精悍的pandas骚操作</a><br><a href="https://mp.weixin.qq.com/s/LoFWiuCteDPgO4P3CAHqHw">数据分析打工人的Pandas75个高频操作（收藏查询用~）</a><br><a href="https://mp.weixin.qq.com/s/DnLJbvVUhTx87-S24FXd8w">一文详解Python-Conda包管理工具</a><br><a href="https://mp.weixin.qq.com/s/YYS2Oq9UvryHKEvJ5MONXA">这些10种Numpy高级操作你都会吗？</a></p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>Python代码笔记</title>
    <url>/studyz.github.io/2022/04/28/2023_03_15_Python%E4%BB%A3%E7%A0%81%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="iloc"><a href="#iloc" class="headerlink" title="iloc"></a>iloc</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.iloc[a,b]</span><br><span class="line"><span class="comment"># 其中df是DataFrame数据结构的数据，a是 #行索引，b是 #列索引。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line">df = pandas.read_csv(<span class="string">&#x27;a.csv&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.iloc[<span class="number">0</span>:<span class="number">2</span>,<span class="number">2</span>]) <span class="comment">#数据结构是Series</span></span><br><span class="line"><span class="built_in">print</span>(df.iloc[<span class="number">0</span>:<span class="number">2</span>,<span class="number">2</span>].values) <span class="comment">#数据结构是ndarray</span></span><br><span class="line"><span class="comment">#Out1：0    87</span></span><br><span class="line"><span class="comment">#      1    95</span></span><br><span class="line"><span class="comment"># Name: 分数, dtype: int64</span></span><br><span class="line"><span class="comment">#Out2：[87 95]</span></span><br></pre></td></tr></table></figure>

<h3 id="解除列打印限制"><a href="#解除列打印限制" class="headerlink" title="解除列打印限制"></a>解除列打印限制</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置expand_frame_repr属性为False，即可在打印输出dataframe时不隐藏部分列</span></span><br><span class="line"></span><br><span class="line">pd.set_option(<span class="string">&#x27;expand_frame_repr&#x27;</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Python-pandas-读取数据-read-excel"><a href="#Python-pandas-读取数据-read-excel" class="headerlink" title="Python&#x2F;pandas&#x2F;读取数据&#x2F;read_excel"></a>Python&#x2F;pandas&#x2F;读取数据&#x2F;read_excel</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">excel_dataframe = pd.read_excel(xlsx_file, sheet_name = worksheet_name, header=head_count, skipfooter=tail_count, dtype=<span class="string">&#x27;str&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Python-pandas-读取数据-csv"><a href="#Python-pandas-读取数据-csv" class="headerlink" title="Python&#x2F;pandas&#x2F;读取数据&#x2F;csv"></a>Python&#x2F;pandas&#x2F;读取数据&#x2F;csv</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_csv(<span class="string">&quot;data.csv&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>对于Windows的读取方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_csv(<span class="string">&#x27;my_data.csv&#x27;</span>, encoding=<span class="string">&#x27;ANSI&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>Mac上修改为使用GB18030的编码来读取文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_csv(<span class="string">&#x27;my_data.csv&#x27;</span>, encoding=<span class="string">&quot;gb18030&quot;</span>, on_bad_lines=<span class="string">&quot;skip&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Python-pandas-读取数据-csv-从多个csv文件中读取数据"><a href="#Python-pandas-读取数据-csv-从多个csv文件中读取数据" class="headerlink" title="Python&#x2F;pandas&#x2F;读取数据&#x2F;csv&#x2F;从多个csv文件中读取数据"></a>Python&#x2F;pandas&#x2F;读取数据&#x2F;csv&#x2F;从多个csv文件中读取数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">files = glob.glob(<span class="string">&quot;file_*.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line">result = pd.concat([pd.read_csv(file) <span class="keyword">for</span> file <span class="keyword">in</span> files], ignore_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Python-读取数据-从PDF文件当中来读取数据"><a href="#Python-读取数据-从PDF文件当中来读取数据" class="headerlink" title="Python&#x2F;读取数据&#x2F;从PDF文件当中来读取数据"></a>Python&#x2F;读取数据&#x2F;从PDF文件当中来读取数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装tabula-py模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %pip install tabula-py </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tabula <span class="keyword">import</span> read_pdf</span><br><span class="line"></span><br><span class="line">df = read_pdf(<span class="string">&#x27;test.pdf&#x27;</span>, pages=<span class="string">&#x27;all&#x27;</span>)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="comment">### Python/pandas/读取数据/部分读取/指定列</span></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">df = pd.read_csv(<span class="string">&quot;house_price.csv&quot;</span>, usecols=[<span class="string">&quot;Id&quot;</span>, <span class="string">&quot;SalePrice&quot;</span>])</span><br><span class="line"></span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>

<h3 id="Python-pandas-读取数据-部分读取-指定行"><a href="#Python-pandas-读取数据-部分读取-指定行" class="headerlink" title="Python&#x2F;pandas&#x2F;读取数据&#x2F;部分读取&#x2F;指定行"></a>Python&#x2F;pandas&#x2F;读取数据&#x2F;部分读取&#x2F;指定行</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&quot;Tesla.csv&quot;</span>, nrows=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">df.shape</span><br></pre></td></tr></table></figure>

<h3 id="Python-探索性数据分析"><a href="#Python-探索性数据分析" class="headerlink" title="Python&#x2F;探索性数据分析"></a>Python&#x2F;探索性数据分析</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装pandas-profilling模块</span></span><br><span class="line"><span class="comment"># %pip install pandas-profiling</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas_profiling</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&quot;data.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line">profile = df.profile_report(title=<span class="string">&quot;Pandas Profiling Report&quot;</span>)</span><br><span class="line"></span><br><span class="line">profile.to_file(output_file=<span class="string">&quot;output.html&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Python-pandas-基于数据类型的操作-筛选数据"><a href="#Python-pandas-基于数据类型的操作-筛选数据" class="headerlink" title="Python&#x2F;pandas&#x2F;&#x2F;基于数据类型的操作&#x2F;筛选数据"></a>Python&#x2F;pandas&#x2F;&#x2F;基于数据类型的操作&#x2F;筛选数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.select_dtypes(include=<span class="string">&quot;number&quot;</span>)</span><br><span class="line"></span><br><span class="line">df.select_dtypes(include=[<span class="string">&quot;category&quot;</span>, <span class="string">&quot;datetime&quot;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Python-pandas-基于数据类型的操作-排除数据"><a href="#Python-pandas-基于数据类型的操作-排除数据" class="headerlink" title="Python&#x2F;pandas&#x2F;&#x2F;基于数据类型的操作&#x2F;排除数据"></a>Python&#x2F;pandas&#x2F;&#x2F;基于数据类型的操作&#x2F;排除数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.select_dtypes(exclude=<span class="string">&quot;object&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Python-pandas-基于数据类型的操作-推断数据类型"><a href="#Python-pandas-基于数据类型的操作-推断数据类型" class="headerlink" title="Python&#x2F;pandas&#x2F;基于数据类型的操作&#x2F;推断数据类型"></a>Python&#x2F;pandas&#x2F;基于数据类型的操作&#x2F;推断数据类型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.infer_objects().dtypes</span><br></pre></td></tr></table></figure>

<h3 id="Python-pandas-基于数据类型的操作-手动进行数据类型的转换"><a href="#Python-pandas-基于数据类型的操作-手动进行数据类型的转换" class="headerlink" title="Python&#x2F;pandas&#x2F;基于数据类型的操作&#x2F;手动进行数据类型的转换"></a>Python&#x2F;pandas&#x2F;基于数据类型的操作&#x2F;手动进行数据类型的转换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 针对整个数据集都有效</span></span><br><span class="line"></span><br><span class="line">df = df.apply(pd.to_numeric, errors=<span class="string">&quot;coerce&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将空值用零来填充</span></span><br><span class="line"></span><br><span class="line">pd.to_numeric(df.numeric_column, errors=<span class="string">&quot;coerce&quot;</span>).fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Python-pandas-基于数据类型的操作-一次性完成数据类型的转换"><a href="#Python-pandas-基于数据类型的操作-一次性完成数据类型的转换" class="headerlink" title="Python&#x2F;pandas&#x2F;基于数据类型的操作&#x2F;一次性完成数据类型的转换"></a>Python&#x2F;pandas&#x2F;基于数据类型的操作&#x2F;一次性完成数据类型的转换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.astype(</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;date&quot;</span>: <span class="string">&quot;datetime64[ns]&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;price&quot;</span>: <span class="string">&quot;int&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;is_weekend&quot;</span>: <span class="string">&quot;bool&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;category&quot;</span>,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="Python-pandas-列的操作-获取指定列"><a href="#Python-pandas-列的操作-获取指定列" class="headerlink" title="Python&#x2F;pandas&#x2F;列的操作&#x2F;获取指定列"></a>Python&#x2F;pandas&#x2F;列的操作&#x2F;获取指定列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;列表头&#x27;</span>]</span><br><span class="line"></span><br><span class="line">df[[[<span class="string">&#x27;列1&#x27;</span>,<span class="string">&#x27;列2&#x27;</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Python-forLoop-enumerate"><a href="#Python-forLoop-enumerate" class="headerlink" title="Python&#x2F;forLoop&#x2F;enumerate"></a>Python&#x2F;forLoop&#x2F;enumerate</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, element <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">list</span>):</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(idx,element)</span><br></pre></td></tr></table></figure>


<h3 id="Python-pandas-列的操作-重命名"><a href="#Python-pandas-列的操作-重命名" class="headerlink" title="Python&#x2F;pandas&#x2F;列的操作&#x2F;重命名"></a>Python&#x2F;pandas&#x2F;列的操作&#x2F;重命名</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.rename(&#123;<span class="string">&quot;PRICE&quot;</span>: <span class="string">&quot;price&quot;</span>, <span class="string">&quot;Date (mm/dd/yyyy)&quot;</span>: <span class="string">&quot;date&quot;</span>, <span class="string">&quot;STATUS&quot;</span>: <span class="string">&quot;status&quot;</span>&#125;, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>


<h3 id="Python-pandas-列的操作-添加前缀或者是后缀"><a href="#Python-pandas-列的操作-添加前缀或者是后缀" class="headerlink" title="Python&#x2F;pandas&#x2F;列的操作&#x2F;添加前缀或者是后缀"></a>Python&#x2F;pandas&#x2F;列的操作&#x2F;添加前缀或者是后缀</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.add_prefix(<span class="string">&quot;pre_&quot;</span>)</span><br><span class="line"></span><br><span class="line">df.add_suffix(<span class="string">&quot;_suf&quot;</span>)</span><br></pre></td></tr></table></figure>


<h3 id="Python-pandas-列的操作-新建一个列"><a href="#Python-pandas-列的操作-新建一个列" class="headerlink" title="Python&#x2F;pandas&#x2F;列的操作&#x2F;新建一个列"></a>Python&#x2F;pandas&#x2F;列的操作&#x2F;新建一个列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 摄氏度与华氏度之间的数制转换</span></span><br><span class="line"></span><br><span class="line">df.assign(temp_f=<span class="keyword">lambda</span> x: x.temp_c * <span class="number">9</span> / <span class="number">5</span> + <span class="number">32</span>)</span><br></pre></td></tr></table></figure>


<h3 id="Python-pandas-列的操作-新建一个列-从已有列复制部分"><a href="#Python-pandas-列的操作-新建一个列-从已有列复制部分" class="headerlink" title="Python&#x2F;pandas&#x2F;列的操作&#x2F;新建一个列&#x2F;从已有列复制部分"></a>Python&#x2F;pandas&#x2F;列的操作&#x2F;新建一个列&#x2F;从已有列复制部分</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raw_df[<span class="string">&#x27;消耗日期&#x27;</span>] = raw_df[<span class="string">&quot;消耗时间&quot;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h3 id="Python-pandas-列的操作-在指定的位置插入新的一列"><a href="#Python-pandas-列的操作-在指定的位置插入新的一列" class="headerlink" title="Python&#x2F;pandas&#x2F;列的操作&#x2F;在指定的位置插入新的一列"></a>Python&#x2F;pandas&#x2F;列的操作&#x2F;在指定的位置插入新的一列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">random_col = np.random.randint(<span class="number">10</span>, size=<span class="built_in">len</span>(df))</span><br><span class="line"></span><br><span class="line">df.insert(<span class="number">3</span>, <span class="string">&#x27;random_col&#x27;</span>, random_col) <span class="comment"># 在第三列的地方插入</span></span><br></pre></td></tr></table></figure>

<h3 id="Python-pandas-列的操作-if-else逻辑判断"><a href="#Python-pandas-列的操作-if-else逻辑判断" class="headerlink" title="Python&#x2F;pandas&#x2F;列的操作&#x2F;if-else逻辑判断"></a>Python&#x2F;pandas&#x2F;列的操作&#x2F;if-else逻辑判断</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&quot;price_high_low&quot;</span>] = np.where(df[<span class="string">&quot;price&quot;</span>] &gt; <span class="number">5</span>, <span class="string">&quot;high&quot;</span>, <span class="string">&quot;low&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Python-pandas-列的操作-去掉某些列"><a href="#Python-pandas-列的操作-去掉某些列" class="headerlink" title="Python&#x2F;pandas&#x2F;列的操作&#x2F;去掉某些列"></a>Python&#x2F;pandas&#x2F;列的操作&#x2F;去掉某些列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> sku_dataframe[<span class="string">&#x27;批次id&#x27;</span>]</span><br><span class="line"></span><br><span class="line">df.drop(<span class="string">&#x27;col1&#x27;</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">df = df.drop([<span class="string">&#x27;col1&#x27;</span>,<span class="string">&#x27;col2&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">df.drop(df.columns[<span class="number">0</span>], inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Python-pandas-字符串的操作-列名的操作"><a href="#Python-pandas-字符串的操作-列名的操作" class="headerlink" title="Python&#x2F;pandas&#x2F;字符串的操作&#x2F;列名的操作"></a>Python&#x2F;pandas&#x2F;字符串的操作&#x2F;列名的操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对于列名的字符串操作</span></span><br><span class="line"></span><br><span class="line">df.columns = df.columns.<span class="built_in">str</span>.lower()</span><br><span class="line"></span><br><span class="line">df.columns = df.columns.<span class="built_in">str</span>.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;_&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Python-pandas-字符串的操作-Contains-方法"><a href="#Python-pandas-字符串的操作-Contains-方法" class="headerlink" title="Python&#x2F;pandas&#x2F;字符串的操作&#x2F;Contains()方法"></a>Python&#x2F;pandas&#x2F;字符串的操作&#x2F;Contains()方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 是否包含了某些字符串</span></span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;name&#x27;</span>].<span class="built_in">str</span>.contains(<span class="string">&quot;John&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 里面可以放置正则表达式</span></span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;phone_num&#x27;</span>].<span class="built_in">str</span>.contains(<span class="string">&#x27;...-...-....&#x27;</span>, regex=<span class="literal">True</span>) <span class="comment"># regex</span></span><br></pre></td></tr></table></figure>

<h3 id="Python-pandas-字符串的操作-findall-方法"><a href="#Python-pandas-字符串的操作-findall-方法" class="headerlink" title="Python&#x2F;pandas&#x2F;字符串的操作&#x2F;findall()方法"></a>Python&#x2F;pandas&#x2F;字符串的操作&#x2F;findall()方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 正则表达式</span></span><br><span class="line"></span><br><span class="line">pattern = <span class="string">&#x27;([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\\.([A-Z]&#123;1,9&#125;)&#x27;</span></span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;email&#x27;</span>].<span class="built_in">str</span>.findall(pattern, flags=re.IGNORECASE)</span><br></pre></td></tr></table></figure>


<h3 id="Python-pandas-缺失值-查看空值的比例"><a href="#Python-pandas-缺失值-查看空值的比例" class="headerlink" title="Python&#x2F;pandas&#x2F;缺失值&#x2F;查看空值的比例"></a>Python&#x2F;pandas&#x2F;缺失值&#x2F;查看空值的比例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">missing_vals</span>(<span class="params">df</span>):</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;空值所占的百分比&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">missing = [</span><br><span class="line"></span><br><span class="line">(df.columns[idx], perc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, perc <span class="keyword">in</span> <span class="built_in">enumerate</span>(df.isna().mean() * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> perc &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(missing) == <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;没有空值数据的存在&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line"></span><br><span class="line">missing.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;总共有 <span class="subst">&#123;<span class="built_in">len</span>(missing)&#125;</span> 个变量存在空值\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tup <span class="keyword">in</span> missing:</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.ljust(<span class="string">f&quot;<span class="subst">&#123;tup[<span class="number">0</span>]:&lt;<span class="number">20</span>&#125;</span> =&gt; <span class="subst">&#123;<span class="built_in">round</span>(tup[<span class="number">1</span>], <span class="number">3</span>)&#125;</span>%&quot;</span>, <span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="Python-缺失值-空值的处理方式"><a href="#Python-缺失值-空值的处理方式" class="headerlink" title="Python&#x2F;缺失值&#x2F;空值的处理方式"></a>Python&#x2F;缺失值&#x2F;空值的处理方式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 去除掉空值</span></span><br><span class="line"></span><br><span class="line">df.dropna(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">df.dropna(axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 换成其他值来填充</span></span><br><span class="line"></span><br><span class="line">df.fillna(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">df.fillna(method=<span class="string">&quot;ffill&quot;</span>)</span><br><span class="line"></span><br><span class="line">df.fillna(method=<span class="string">&#x27;bfill&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取代为其他的数值</span></span><br><span class="line"></span><br><span class="line">df.replace( -<span class="number">999</span>, np.nan)</span><br><span class="line"></span><br><span class="line">df.replace(<span class="string">&quot;?&quot;</span>, np.nan)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推测其空值应该为其他什么数值</span></span><br><span class="line"></span><br><span class="line">ts.interpolate() <span class="comment"># time series</span></span><br><span class="line"></span><br><span class="line">df.interpolate() <span class="comment"># fill all consecutive values forward</span></span><br><span class="line"></span><br><span class="line">df.interpolate(limit=<span class="number">1</span>) <span class="comment"># fill one consecutive value forward</span></span><br><span class="line"></span><br><span class="line">df.interpolate(limit=<span class="number">1</span>, limit_direction=<span class="string">&quot;backward&quot;</span>)</span><br><span class="line"></span><br><span class="line">df.interpolate(limit_direction=<span class="string">&quot;both&quot;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="Python-日期格式的数据处理-获取指定时间的数据"><a href="#Python-日期格式的数据处理-获取指定时间的数据" class="headerlink" title="Python&#x2F;日期格式的数据处理&#x2F;获取指定时间的数据"></a>Python&#x2F;日期格式的数据处理&#x2F;获取指定时间的数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 从今天开始算，之后的N天或者N个礼拜或者N个小时</span></span><br><span class="line"></span><br><span class="line">date.today() + datetime.timedelta(hours=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">date.today() + datetime.timedelta(days=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">date.today() + datetime.timedelta(weeks=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 过去的一年</span></span><br><span class="line"></span><br><span class="line">date.today() - datetime.timedelta(days=<span class="number">365</span>)</span><br></pre></td></tr></table></figure>



<h3 id="Python-日期格式的数据处理-通过日期时间来获取数据"><a href="#Python-日期格式的数据处理-通过日期时间来获取数据" class="headerlink" title="Python&#x2F;日期格式的数据处理&#x2F;通过日期时间来获取数据"></a>Python&#x2F;日期格式的数据处理&#x2F;通过日期时间来获取数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[(df[<span class="string">&quot;Date&quot;</span>] &gt; <span class="string">&quot;2015-10-01&quot;</span>) &amp; (df[<span class="string">&quot;Date&quot;</span>] &lt; <span class="string">&quot;2018-01-05&quot;</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="Python-日期格式的数据处理-通过指定日期来获取数据"><a href="#Python-日期格式的数据处理-通过指定日期来获取数据" class="headerlink" title="Python&#x2F;日期格式的数据处理&#x2F;通过指定日期来获取数据"></a>Python&#x2F;日期格式的数据处理&#x2F;通过指定日期来获取数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 筛选出某一天的数据</span></span><br><span class="line"></span><br><span class="line">df[df[<span class="string">&quot;Date&quot;</span>].dt.strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>) == <span class="string">&quot;2022-03-05&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选出某一个月的数据</span></span><br><span class="line"></span><br><span class="line">df[df[<span class="string">&quot;Date&quot;</span>].dt.strftime(<span class="string">&quot;%m&quot;</span>) == <span class="string">&quot;12&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选出每一年的数据</span></span><br><span class="line"></span><br><span class="line">df[df[<span class="string">&quot;Date&quot;</span>].dt.strftime(<span class="string">&quot;%Y&quot;</span>) == <span class="string">&quot;2020&quot;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Python-将格式化数据集-保留指定位数"><a href="#Python-将格式化数据集-保留指定位数" class="headerlink" title="Python&#x2F;将格式化数据集&#x2F;保留指定位数"></a>Python&#x2F;将格式化数据集&#x2F;保留指定位数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">format_dict = &#123;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Open&quot;</span>: <span class="string">&quot;$&#123;:.2f&#125;&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Close&quot;</span>: <span class="string">&quot;$&#123;:.2f&#125;&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Volume&quot;</span>: <span class="string">&quot;&#123;:,&#125;&quot;</span>,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">df.style.<span class="built_in">format</span>(format_dict)</span><br></pre></td></tr></table></figure>


<h3 id="Python-将格式化数据集-高亮显示数据"><a href="#Python-将格式化数据集-高亮显示数据" class="headerlink" title="Python&#x2F;将格式化数据集&#x2F;高亮显示数据"></a>Python&#x2F;将格式化数据集&#x2F;高亮显示数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(</span><br><span class="line"></span><br><span class="line">df.style.<span class="built_in">format</span>(format_dict)</span><br><span class="line"></span><br><span class="line">.hide_index()</span><br><span class="line"></span><br><span class="line">.highlight_min([<span class="string">&quot;Open&quot;</span>], color=<span class="string">&quot;blue&quot;</span>)</span><br><span class="line"></span><br><span class="line">.highlight_max([<span class="string">&quot;Open&quot;</span>], color=<span class="string">&quot;red&quot;</span>)</span><br><span class="line"></span><br><span class="line">.background_gradient(subset=<span class="string">&quot;Close&quot;</span>, cmap=<span class="string">&quot;Greens&quot;</span>)</span><br><span class="line"></span><br><span class="line">.bar(<span class="string">&#x27;Volume&#x27;</span>, color=<span class="string">&#x27;lightblue&#x27;</span>, align=<span class="string">&#x27;zero&#x27;</span>)</span><br><span class="line"></span><br><span class="line">.set_caption(<span class="string">&#x27;Tesla Stock Prices in 2017&#x27;</span>)</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="Python-将格式化数据集-pandas-styler"><a href="#Python-将格式化数据集-pandas-styler" class="headerlink" title="Python&#x2F;将格式化数据集&#x2F;pandas-styler"></a>Python&#x2F;将格式化数据集&#x2F;pandas-styler</h3><p>pandas也可以像excel一样，设置表格的可视化条件格式，而且只需要一行代码即可（可能需要一丢丢的前端HTML和CSS基础知识）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">diabetes.describe().T.drop(<span class="string">&quot;count&quot;</span>, axis=<span class="number">1</span>).style.highlight_max(color=<span class="string">&quot;darkred&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Python-数据输出设置宽度"><a href="#Python-数据输出设置宽度" class="headerlink" title="Python&#x2F;数据输出设置宽度"></a>Python&#x2F;数据输出设置宽度</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = wechat_csv_reader(file_name,<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">xlswriter = pd.ExcelWriter(<span class="string">&quot;test.xlsx&quot;</span>)</span><br><span class="line"></span><br><span class="line">df.to_excel(xlswriter,<span class="string">&#x27;核销明细&#x27;</span>,index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">worksheet = xlswriter.sheets[<span class="string">&#x27;核销明细&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定B列宽度设置成12</span></span><br><span class="line"></span><br><span class="line">worksheet.set_column(<span class="string">&#x27;B:B&#x27;</span>, <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定1-4列宽度设置成15</span></span><br><span class="line"></span><br><span class="line">worksheet.set_column(<span class="number">1</span>, <span class="number">4</span>, <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">xlswriter.save()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Python-路径-pathlib"><a href="#Python-路径-pathlib" class="headerlink" title="Python&#x2F;路径&#x2F;pathlib"></a>Python&#x2F;路径&#x2F;pathlib</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">Path.cwd() <span class="comment">#返回文件当前所在目录；</span></span><br><span class="line"></span><br><span class="line">Path.home()<span class="comment">#返回电脑用户的目录。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接出Windows桌面路径</span></span><br><span class="line"></span><br><span class="line">Path.joinpath(Path.home(), <span class="string">&quot;Desktop&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Python-pandas-列的操作-判断open这一列列是否有NaN"><a href="#Python-pandas-列的操作-判断open这一列列是否有NaN" class="headerlink" title="Python&#x2F;pandas&#x2F;列的操作&#x2F;判断open这一列列是否有NaN"></a>Python&#x2F;pandas&#x2F;列的操作&#x2F;判断open这一列列是否有NaN</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;$open&#x27;</span>].isnull().<span class="built_in">any</span>() <span class="comment"># 判断open这一列列是否有 NaN</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Python-pandas-列的操作-判断全部是否有NaN"><a href="#Python-pandas-列的操作-判断全部是否有NaN" class="headerlink" title="Python&#x2F;pandas&#x2F;列的操作&#x2F;判断全部是否有NaN"></a>Python&#x2F;pandas&#x2F;列的操作&#x2F;判断全部是否有NaN</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">df[<span class="string">&#x27;$open&#x27;</span>].isnull().<span class="built_in">all</span>() <span class="comment"># 判断open列是否全部为NaN</span></span><br><span class="line"></span><br><span class="line">df.isnull().<span class="built_in">all</span>() <span class="comment"># 判断某列是否全部为NaN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df.drop_duplicates()</span><br><span class="line"></span><br><span class="line"><span class="comment">#保留重复项</span></span><br><span class="line"></span><br><span class="line">df.drop_duplicates(keep=Flase)</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除重复的项</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空返回true，非空返回false</span></span><br><span class="line"></span><br><span class="line">df.empty</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new_list = [<span class="string">&#x27;1&#x27;</span>+x <span class="keyword">for</span> x <span class="keyword">in</span> old_list]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df.drop(df.tail(n).index) 从尾部去掉 n 行</span><br><span class="line"></span><br><span class="line">df.dorp(df.head(n).index) 从头去掉 n 行</span><br><span class="line"></span><br><span class="line">可以加上 inplace=<span class="literal">True</span> 直接修改原 dataFrame，不过函数返回是 <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按列筛选</span></span><br><span class="line"></span><br><span class="line">new_df = raw_sum_df[raw_sum_df[<span class="string">&#x27;活动名称&#x27;</span>]==‘活动’]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选在列表中存在的</span></span><br><span class="line"></span><br><span class="line">new_df = raw_sum_df[raw_sum_df[<span class="string">&#x27;活动名称&#x27;</span>].isin(voucher_name_list)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选在不在列表中存在的</span></span><br><span class="line"></span><br><span class="line">new_df = raw_sum_df[raw_sum_df[<span class="string">&#x27;活动名称&#x27;</span>].isin(voucher_name_list)]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [9]: bool([0,0,0])</span><br><span class="line"></span><br><span class="line">Out[9]: True</span><br><span class="line"></span><br><span class="line">In [10]: bool([])</span><br><span class="line"></span><br><span class="line">Out[10]: False</span><br><span class="line"></span><br><span class="line">In [11]: bool([1,0,1])</span><br><span class="line"></span><br><span class="line">Out[11]: True</span><br></pre></td></tr></table></figure>


<p>#######################</p>
<h1 id="时间转换位时间戳"><a href="#时间转换位时间戳" class="headerlink" title="时间转换位时间戳"></a>时间转换位时间戳</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">t = <span class="string">&quot;2017-11-24 17:30:00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将其转换为时间数组</span></span><br><span class="line"></span><br><span class="line">timeStruct = time.strptime(t, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#转换为时间戳:</span></span><br><span class="line"></span><br><span class="line">timeStamp = <span class="built_in">int</span>(time.mktime(timeStruct))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(timeStamp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"></span><br><span class="line"><span class="number">1511515800</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间戳转换为指定格式日期</span></span><br><span class="line"></span><br><span class="line">timeStamp = <span class="number">1511515800</span></span><br><span class="line"></span><br><span class="line">localTime = time.localtime(timeStamp)</span><br><span class="line"></span><br><span class="line">strTime = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, localTime)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(strTime)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"></span><br><span class="line"><span class="number">2017</span>-<span class="number">11</span>-<span class="number">24</span> <span class="number">17</span>:<span class="number">30</span>:<span class="number">00</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str 转 time 类型</span></span><br><span class="line"></span><br><span class="line">date_time = time.strptime(date_time_str , <span class="string">&quot;%Y/%m/%d %H:%M:%S&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line">d = path.dirname(__file__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得d所在的目录,即d的父级目录</span></span><br><span class="line"></span><br><span class="line">parent_path = os.path.dirname(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得parent_path所在的目录即parent_path的父级目录</span></span><br><span class="line"></span><br><span class="line">parent_path2 = os.path.dirname(parent_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取今天（现在时间）</span></span><br><span class="line"></span><br><span class="line">today = datetime.datetime.today()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 昨天</span></span><br><span class="line"></span><br><span class="line">yesterday = today - datetime.timedelta(days=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 明天</span></span><br><span class="line"></span><br><span class="line">tomorrow = today + datetime.timedelta(days=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前日期</span></span><br><span class="line"></span><br><span class="line">date = datetime.date.today()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取一秒后的时间</span></span><br><span class="line"></span><br><span class="line">s = today + datetime.timedelta(seconds=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取一分钟后的时间</span></span><br><span class="line"></span><br><span class="line">m = today + datetime.timedelta(minutes=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取一小时后的时间</span></span><br><span class="line"></span><br><span class="line">h = today + datetime.timedelta(hours=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取一年后的时间</span></span><br><span class="line"></span><br><span class="line">y = today + datetime.timedelta(days=<span class="number">365</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pandas str转datetime</span></span><br><span class="line"></span><br><span class="line">raw_df[<span class="string">&#x27;消耗时间&#x27;</span>] = pd.to_datetime(raw_df[<span class="string">&#x27;消耗时间&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#datetime转date</span></span><br><span class="line"></span><br><span class="line">raw_df[<span class="string">&#x27;消耗日期&#x27;</span>] = raw_df[<span class="string">&#x27;消耗时间&#x27;</span>].dt.date</span><br><span class="line"></span><br><span class="line"><span class="comment">#datetime转time</span></span><br><span class="line"></span><br><span class="line">raw_df[<span class="string">&#x27;消耗日期&#x27;</span>] = raw_df[<span class="string">&#x27;消耗时间&#x27;</span>].dt.time</span><br><span class="line"></span><br><span class="line"><span class="comment">#datetime提取年、月、日</span></span><br><span class="line"></span><br><span class="line">raw_df[<span class="string">&#x27;消耗日期&#x27;</span>] = raw_df[<span class="string">&#x27;消耗时间&#x27;</span>].dt.year</span><br><span class="line"></span><br><span class="line">raw_df[<span class="string">&#x27;消耗日期&#x27;</span>] = raw_df[<span class="string">&#x27;消耗时间&#x27;</span>].dt.month</span><br><span class="line"></span><br><span class="line">raw_df[<span class="string">&#x27;消耗日期&#x27;</span>] = raw_df[<span class="string">&#x27;消耗时间&#x27;</span>].dt.day</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断一周里的第几天，Monday=0, Sunday=6</span></span><br><span class="line"></span><br><span class="line">raw_df[<span class="string">&#x27;消耗日期&#x27;</span>] = raw_df[<span class="string">&#x27;消耗时间&#x27;</span>].dt.weekday</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>#df 为dataframe对象，包含’word’, ‘count’两列数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">result_dic = df.groupby(<span class="string">&#x27;word&#x27;</span>)[<span class="string">&#x27;count&#x27;</span>].apply(<span class="built_in">list</span>).to_dict()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于同一个key对应多个value，则把同一key的value构成一个list</span></span><br><span class="line"></span><br><span class="line">result_dic = df.groupby(<span class="string">&#x27;word&#x27;</span>)[<span class="string">&#x27;count&#x27;</span>].apply(<span class="keyword">lambda</span> x:<span class="built_in">str</span>(x)).to_dict()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于同一个key对应一个value，直接使用value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#形如&#123;key:value&#125;的字典</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####################### 方法二</span></span><br><span class="line"></span><br><span class="line">result_dic = df.set_index(<span class="string">&#x27;a&#x27;</span>).T.to_dict()</span><br><span class="line"></span><br><span class="line">result_dic = df[[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]].set_index(<span class="string">&quot;a&quot;</span>).to_dict()[<span class="string">&quot;b&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 形如&#123;key:&#123;&#x27;count&#x27;:value&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># dataframe转array</span></span><br><span class="line"></span><br><span class="line">l = dataframe[<span class="string">&#x27;&#x27;</span>].values.tolist()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典转dataframe</span></span><br><span class="line"></span><br><span class="line">barcode_newDF = pd.DataFrame(barcode_newDF_dic)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> sku_dataframe[<span class="string">&#x27;批次id&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置index</span></span><br><span class="line"></span><br><span class="line">la = byid_df.reset_index(drop=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已有A列，增加空列</span></span><br><span class="line"></span><br><span class="line">df.reindex(columns=[‘A’,’B’,’C’] fill_value=‘’)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取多列（new_df为DataFrame类型）</span></span><br><span class="line"></span><br><span class="line">new_df = df[[<span class="string">&#x27;column_name1&#x27;</span>, <span class="string">&#x27;column_name2&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回df【列】的list</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(voucher_setting_dataframe))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选取特定列</span></span><br><span class="line"></span><br><span class="line">pick_cloums_list = [<span class="string">&quot;券批次号&quot;</span>, <span class="string">&quot;发券形式&quot;</span>, <span class="string">&quot;商品名称&quot;</span>, <span class="string">&quot;核销门槛&quot;</span>, <span class="string">&quot;单张优惠金额&quot;</span>, <span class="string">&quot;发券量&quot;</span>, <span class="string">&quot;已发券数&quot;</span>]</span><br><span class="line"></span><br><span class="line">dataframe = voucher_setting_dataframe[pick_cloums_list]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理dataframe中的“`”</span></span><br><span class="line"></span><br><span class="line">raw_sum_df = raw_sum_dataframe.replace(&#123;<span class="string">&quot;`&quot;</span>:<span class="string">&quot;&quot;</span>&#125;,regex=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改index</span></span><br><span class="line"></span><br><span class="line">DataFrame.index = [newName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将DataFrame格式的数据转化成字典形式</span></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">dict_country = df.set_index(<span class="string">&#x27;project&#x27;</span>).T.to_dict(<span class="string">&#x27;list&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种:在读取数据的时候,指定数据类型</span></span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;test.txt&#x27;</span>,sep = <span class="string">&#x27;|&#x27;</span>,dtype = <span class="string">&#x27;str&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二种:使用转换函数:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.1:将所有数据转换为字符串</span></span><br><span class="line"></span><br><span class="line">dataframe=dataframe.astype(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.2:将某列转换为字符串</span></span><br><span class="line"></span><br><span class="line">data = data.astype(&#123;<span class="string">&#x27;outcome&#x27;</span>:<span class="string">&#x27;float&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="string">&#x27;int&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第三种:使用dataframe的apply函数或者map函数</span></span><br><span class="line"></span><br><span class="line">data[<span class="string">&#x27;交易金额&#x27;</span>] = data.交易金额.<span class="built_in">map</span>(<span class="keyword">lambda</span> x:<span class="built_in">float</span>(x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[wechat data structure](https://www.notion.so/wechat-data-structure-1a305743622043908c44c6be5dc1f999)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改指定多列的数据类型</span></span><br><span class="line"></span><br><span class="line">df[[<span class="string">&#x27;c3&#x27;</span>,<span class="string">&#x27;c5&#x27;</span>]] = df[[<span class="string">&#x27;c3&#x27;</span>,<span class="string">&#x27;c5&#x27;</span>]].apply(pd.to_numeric)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.dtypes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改单列的数据类型</span></span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;column_name&#x27;</span>] = df[<span class="string">&#x27;column_name&#x27;</span>].astype(np.<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.dtypes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建dataframe时，修改数据类型</span></span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data, dtype=<span class="string">&#x27;float&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.dtypes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取时，修改数据类型</span></span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&quot;somefile.csv&quot;</span>, dtype = &#123;<span class="string">&#x27;column_name&#x27;</span> : <span class="built_in">str</span>&#125;)</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data, dtype=<span class="string">&#x27;float&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加列，填充0</span></span><br><span class="line"></span><br><span class="line">df.insert(<span class="number">1</span>,<span class="string">&#x27;c&#x27;</span>,value=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一列拆封</span></span><br><span class="line"></span><br><span class="line">combined_df[[<span class="string">&#x27;消耗日期&#x27;</span>, <span class="string">&quot;消耗时间&quot;</span>]] = combined_df[<span class="string">&quot;消耗时间&quot;</span>].<span class="built_in">str</span>.split(<span class="string">&#x27; &#x27;</span>, <span class="number">2</span>, expand = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列改名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">voucher_setting_df_1 = voucher_setting_df.rename(columns=&#123;<span class="string">&#x27;券批次号&#x27;</span>:<span class="string">&#x27;批次id&#x27;</span>,<span class="string">&#x27;券名称&#x27;</span>:<span class="string">&#x27;券名称&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除头尾的字符strip</span></span><br><span class="line">cleaned_df[<span class="string">&#x27;单品信息&#x27;</span>] = cleaned_df[<span class="string">&#x27;单品信息&#x27;</span>].<span class="built_in">str</span>.strip(<span class="string">&#x27;;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip list #查看已安装的python模块</span><br><span class="line"></span><br><span class="line">pip freeze &gt;requirements.txt # 导出依赖库名称</span><br><span class="line"></span><br><span class="line">pip download -d packages -r requirements.txt #下载依赖库</span><br><span class="line"></span><br><span class="line">pip install --no-index --find-links=packages -r requirements.txt #将`packages`文件夹和`requirements.txt`文件拷贝至离线机器任意同级目录下，以管理员权限启动cmd命令窗口进入该目录，执行下述命令进行离线安装。</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析师</title>
    <url>/studyz.github.io/2023/05/15/2023_03_15_%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据分析师"><a href="#数据分析师" class="headerlink" title="数据分析师"></a>数据分析师</h1><ol>
<li><p>特点：独当一面、战斗力极强、对企业决策者有一定的影响</p>
</li>
<li><p>主要的工作：除了被动的常规分析外，还要能主动发现业务存在的问题，会用数据找事，梳理业务发展与指标体系之间的关系，从日常监督分析开始，更多的是专题性的分析，无中生有</p>
</li>
<li><p>需要掌握的：</p>
<ul>
<li>硬性技能：SQL、EXCEL、PPT、python\spss\R任选其一，tableau\FineBI\powerbi，也要懂一些市面上流行的数据产品</li>
<li>软性技能：沟通能力、表达能力、逻辑思维强</li>
<li>掌握的方法论：ABtest、AAARRR、SWOT、RFM、28原则、5W2H，用户及产品生命周期等</li>
<li>掌握的统计学：常规统计指标（均值、中位数、分位数等)、回归、聚类、因子、决策树、逻辑回归、机器学习等，这些足够用了</li>
<li>加分项：图表可视化、PPT展示、系统性思维、在行业有很多认识和沉淀</li>
<li>要点：算法、技术、工具、业务混为一体，样样都要懂</li>
<li>总结：这类目前市场上很紧缺，被称为稀缺动物</li>
</ul>
</li>
</ol>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><h1 id="tableau-FineBI-powerbi"><a href="#tableau-FineBI-powerbi" class="headerlink" title="tableau-FineBI-powerbi"></a>tableau-FineBI-powerbi</h1><h1 id="掌握的方法论"><a href="#掌握的方法论" class="headerlink" title="掌握的方法论"></a>掌握的方法论</h1><ol>
<li>ABtest</li>
<li>AAARRR</li>
<li>SWOT</li>
<li>RFM</li>
<li>28原则</li>
<li>5W2H</li>
<li>用户及产品生命周期等</li>
</ol>
<h1 id="掌握的统计学"><a href="#掌握的统计学" class="headerlink" title="掌握的统计学"></a>掌握的统计学</h1><ol>
<li>常规统计指标（均值、中位数、分位数等)</li>
<li>回归</li>
<li>聚类</li>
<li>因子</li>
<li>决策树</li>
<li>逻辑回归</li>
<li>机器学习</li>
</ol>
<p>? 热力图</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>数据分析师</tag>
      </tags>
  </entry>
  <entry>
    <title>Python网站开发库大全</title>
    <url>/studyz.github.io/2022/04/30/2023_03_15_Python%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E5%BA%93%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>Q：Web 框架到底是什么？<br>A：Web 框架主要用于网站开发。开发者在基于 Web 框架实现自己的业务逻辑。Web 框架实现了很多功能，为实现业务逻辑提供了一套通用方法。  </p>
</blockquote>
<blockquote>
<p>Q：Web 框架有什么作用？<br>A：使用 Web 框架，很多的业务逻辑外的功能不需要自己再去完善，而是使用框架已有的功能就可以。Web 框架使得在进行 网站开发的时候，减少了工作量。  </p>
</blockquote>
<blockquote>
<p>Q：我们为什么要使用 Web 框架？<br>A：Web 框架主要用于网站开发，可以实现数据的交互和业务功能的完善。使用 Web 框架进行 网站开发的时候，在进行数据缓存、数据库访问、数据安全校验等方面，不需要自己再重新实现，而是将业务逻辑相关的代码写入框架就可以。</p>
</blockquote>
<blockquote>
<p>库排序是<strong>按照使用人数和文档的活跃度</strong>为参考进行的, <strong>建议大家使用排名靠前的框架，因为它们的文档更齐全，技术积累要更多，社区更繁盛，能得到更好的支持，</strong> 这样在遇到自己无法解决的问题，可以更快更高效的找到解答的方案。</p>
</blockquote>
<hr>
<h2 id="1-Django-框架"><a href="#1-Django-框架" class="headerlink" title="1. Django 框架"></a><a href="#1-Django-%E6%A1%86%E6%9E%B6" title="1. Django 框架"></a><strong>1. Django 框架</strong></h2><p>官 网：<a href="https://github.com/django/django.git">https://github.com/django/django.git</a></p>
<p>优 点：是一个高层次 Python Web 开发框架，特点是开发快速、代码较少、可扩展性强。Django 采用 MTV（Model、Template、View）模型组织资源，框架功能丰富，模板扩展选择最多。对于专业人员来说，Django 是当之无愧的 Python 排名第一的 Web 开发框架。</p>
<p>缺 点：包括一些轻量级应用不需要的功能模块，不如 Flask 轻便。过度封装很多类和方法，直接使用比较简单，但改动起来比较困难。相比于 C,C++ 性能，Djang 性能偏低。模板实现了代码和样式完全分离，不允许模板里出现 Python 代码，灵活度不够。另外学习曲线也相对陡峭。</p>
<p><a href="https://mmbiz.qpic.cn/sz_mmbiz_png/NOM5HN2icXzyamXia4vqrASM2pALYlNo8WYrEN2TT3JLXOv80vtCf8K0a96VIZhTkJyicLJaIxutXiaj3Bqg35A85Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1"><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/NOM5HN2icXzyamXia4vqrASM2pALYlNo8WYrEN2TT3JLXOv80vtCf8K0a96VIZhTkJyicLJaIxutXiaj3Bqg35A85Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p><a href="#2-Flask-%E6%A1%86%E6%9E%B6" title="2. Flask 框架"></a></p>
<p><strong>2. Flask 框架</strong></p>
<p>官 网：<br><a href="https://flask.palletsprojects.com/en/2.0.x/">https://flask.palletsprojects.com/en/2.0.x/</a></p>
<p>优 点：Flask 是一个 Python Web 开发的微框架，严格来说，它仅提供 Web 服务器支持，不提供全栈开发支持。然而，Flask 非常轻量、非常简单，基于它搭建 Web 系统都以分钟来计时，特别适合小微原型系统的开发。花少时间、产生可用系统，是非常划算的选择。</p>
<p>缺 点：对于大型网站开发，需要设计路由映射的规则，否则导致代码混乱。对新手来说，容易使用低质量的代码创建 “不良的 web 应用程序”。</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_png/iaGGR9eXibkibjc2xlbRh5D0T8OTQYFhT7vAiaftbfrTfdtw80vC1f1v3sZeyM88EESzUMY8gMuCibp7GBn9Bhh293w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1"><img src="https://mmbiz.qpic.cn/mmbiz_png/iaGGR9eXibkibjc2xlbRh5D0T8OTQYFhT7vAiaftbfrTfdtw80vC1f1v3sZeyM88EESzUMY8gMuCibp7GBn9Bhh293w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p><a href="#3-Pyramid-%E6%A1%86%E6%9E%B6" title="3. Pyramid 框架"></a></p>
<p><strong>3. Pyramid 框架</strong></p>
<p>官 网：<a href="https://trypyramid.com/">https://trypyramid.com/</a></p>
<p>优 点：是一个扩展性很强且灵活的 Python Web 开发框架。上手十分容易，比较适合中等规模且边开发边设计的场景。Pyramid 不提供绝对严格的框架定义，根据需求可以扩展开发，对高阶程序员十分友好。</p>
<p>缺 点：国内知名度不高，高级用法需要通过阅读源代码获取灵感。默认使用 Chameleon 模板，灵活度没有成为一个要素。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaGGR9eXibkibjc2xlbRh5D0T8OTQYFhT7v4I1icBJbaweObDQ078rCFMiaScj58Zk10eeKzLdIu15KsnYalbmKXNhw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><a href="#4-web-py-%E6%A1%86%E6%9E%B6" title="4. web.py 框架"></a></p>
<p><strong>4. web.py 框架</strong></p>
<p>官 网：<a href="https://webpy.org/">https://webpy.org/</a></p>
<p>优 点：正如其名，web.py 是一个采用 Python 作为开发语言的 Web 框架，简单且强大。俄罗斯排名第一的 Yandex 搜索引擎基于这个框架开发，Guido van Rossum 认为这是最好的 Python Web 框架，还需要说别的吗？有事实作证、有大牛认可，用起来吧！</p>
<p>缺 点：Web.py 并未像其他框架一样保持与 Python 3 兼容性的最新状态。这不仅意味着缺乏对异步语法的支持，还意味着缺少对已弃用的函数的错误。此外，目前尚不清楚维护者是否有计划在 Python 2 到达其支持生命周期结束后保持 Web.py 的最新状态。</p>
<p><a href="#5-Tornado-%E6%A1%86%E6%9E%B6" title="5. Tornado 框架"></a></p>
<h2 id="5-Tornado-框架"><a href="#5-Tornado-框架" class="headerlink" title="5. Tornado 框架"></a><strong>5. Tornado 框架</strong></h2><p>官 网：</p>
<p><a href="https://www.tornadoweb.org/en/stable/">https://www.tornadoweb.org/en/stable/</a></p>
<p>优 点：Tornado 是一个基于异步网络功能库的 Web 开发框架，因此，它能支持几万个开放连接，Web 服务高效稳定。可见，Tornado 适合高并发场景下的 Web 系统，开发过程需要采用 Tornado 提供的框架，灵活性较差，确定场景后再考虑使用不迟。</p>
<p>缺 点：Tornado 5.0 改进了与 Python 的本机异步功能的集成。因此不再支持 Python 3.3，并且 Python 3.5 用户必须使用 Python 3.5.2 或更高版本。Tornado 6.0 将需要 Python 3.5 及更高版本，并将完全放弃 Python 2 支持。</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="6-TurboGears-框架"><a href="#6-TurboGears-框架" class="headerlink" title="6. TurboGears 框架"></a><a href="#6-TurboGears-%E6%A1%86%E6%9E%B6" title="6. TurboGears 框架"></a><strong>6. TurboGears 框架</strong></h2><p>官 网：</p>
<p><a href="https://www.turbogears.org/">https://www.turbogears.org/</a></p>
<p>优 点：TurboGears 最新版本 试图解决 TurboGears 最初版本、Django、Rails 等框架缺陷，它支持多数据库、JavaScript 工具集、多种数据交换格式等，当然，它开发非常高效，扩展性很强。试问它与 Django 哪个更好？还真不好说，Django 社区更为活跃或许更重要。</p>
<p>缺 点：TurboGears 的一些缺点包括管理功能较为基础，较少的第三方应用程序以及只有初级的文档。TurboGears 的一个重大挑战是它的压倒性。因为它混搭的其他组件都提供无限的灵活性， 当试图决定何种路径来完成一个任务时它是过于复杂的。</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="7-CherryPy-框架"><a href="#7-CherryPy-框架" class="headerlink" title="7. CherryPy 框架"></a><a href="#7-CherryPy-%E6%A1%86%E6%9E%B6" title="7. CherryPy 框架"></a><strong>7. CherryPy 框架</strong></h2><p>官 网：</p>
<p><a href="https://cherrypy.org/">https://cherrypy.org/</a></p>
<p>优 点：CherryPy 能够让开发者按照其他面向对象程序相似的设计方法开发 Web 系统，进而采用最少的代码、最简洁的方式。CherryPy 已经开发了 10 年之久，稳定性较好，非常适合小规模 Web 系统和纯粹的 Python 程序员。感受到了什么？Python 大有一统江湖之势！拭目以待。</p>
<p>缺 点：只包含为 web 页面提供服务所需的少量内容外，它应该尽可能地让人感觉它不像 “web 框架”，而是像任何其他类型的 Python 应用程序一样。CherryPy 包含的位用作低级构建块。包括会话标识符和 cookie 处理，但不包括 HTML 模板。像 Bottle 一样，CherryPy 提供了一种将路由映射到磁盘上的目录以供静态文件服务的方法。</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="8-Falcon-框架"><a href="#8-Falcon-框架" class="headerlink" title="8. Falcon 框架"></a><a href="#8-Falcon-%E6%A1%86%E6%9E%B6" title="8. Falcon 框架"></a><strong>8. Falcon 框架</strong></h2><p>官 网：</p>
<p><a href="http://falconframework.org/">http://falconframework.org/</a></p>
<p>优 点：Falcon 是一个支持大规模微服务 API 或移动 App 后端响应的 Web 开发框架，它完全基于 Python 并提供了非常高的性能、可靠性和可扩展性。Falcon 定位独特且特色鲜明，对于 App 开发者，后端系统构建不妨考虑 Falcon，十之八九是不会后悔的。</p>
<p>缺 点：Falcon 缺点是其打包模块有点太少，有路由，中间件，钩子，除此之外就不提供其他功能了（裸壳）。额外其他功能，比如验证等都需要开发人员来开发扩展。因为其设计中就假设用于构建 REST API。</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="9-Asgineer-框架"><a href="#9-Asgineer-框架" class="headerlink" title="9. Asgineer 框架"></a><a href="#9-Asgineer-%E6%A1%86%E6%9E%B6" title="9. Asgineer 框架"></a><strong>9. Asgineer 框架</strong></h2><p>官 网：</p>
<p><a href="https://asgineer.readthedocs.io/">https://asgineer.readthedocs.io/</a></p>
<p>优 点：Asgineer 是一种编写异步 Web 应用程序的工具，使用尽可能少的抽象，同时仍然提供友好的 API。只需几分钟即可阅读指南和参考资料！在 Uvicorn 上运行 Asgineer 时，它是可用的最快的 Web 框架之一。它支持 http 长轮询、服务器端事件 (SSE) 和 websockets。并且具有以正确（且快速）的方式为资产提供服务的实用程序。</p>
<p>缺 点：中文文档匮乏。</p>
<h2 id="10-Bottle-框架"><a href="#10-Bottle-框架" class="headerlink" title="10. Bottle 框架"></a><a href="#10-Bottle-%E6%A1%86%E6%9E%B6" title="10. Bottle 框架"></a><strong>10. Bottle 框架</strong></h2><p>官 网：</p>
<p><a href="https://bottlepy.org/docs/dev/">https://bottlepy.org/docs/dev/</a></p>
<p>优 点：Bottle 是一个用于 Python 的快速、简单和轻量级的 WSGI 微型网络框架。它作为单个文件模块分发，除了 Python 标准库之外没有任何依赖项。支持干净和动态的 URL。快速和 Pythonic 内置模板引擎，支持 mako、jinja2 和 cheetah 模板。方便地访问表单数据、文件上传、cookie、标题和其他与 HTTP 相关的元数据。</p>
<p>缺 点：Bottle 极简主义的一个后果是有些功能根本就不存在。不支持表单验证，包括 CSRF 保护等功能。如果要构建支持高度用户交互的 Web 应用程序，则需要自己添加它们。</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_png/iaGGR9eXibkibjc2xlbRh5D0T8OTQYFhT7vmZ60TGFscqJgX8Dx5ZTYeYUFQW5tzW6dHLDCTUiatwZ6He0iaT9JTB3Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1"><img src="https://mmbiz.qpic.cn/mmbiz_png/iaGGR9eXibkibjc2xlbRh5D0T8OTQYFhT7vmZ60TGFscqJgX8Dx5ZTYeYUFQW5tzW6dHLDCTUiatwZ6He0iaT9JTB3Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<h2 id="11-Emmett-框架"><a href="#11-Emmett-框架" class="headerlink" title="11. Emmett 框架"></a><a href="#11-Emmett-%E6%A1%86%E6%9E%B6" title="11. Emmett 框架"></a><strong>11. Emmett 框架</strong></h2><p>官 网：</p>
<p><a href="https://emmett.sh/">https://emmett.sh/</a></p>
<p>优 点：编写优雅的代码，专注于您的产品，你应该把更多的时间花在你的产品而不是底层框架上。Emmett 是发明家的框架，因为它旨在简化您的开发过程，其语法简单、易于学习和理解。不要在路由器和不舒服的模式之间浪费时间：每次为应用程序写下路由时，一切都清楚地呈现在您的眼前。</p>
<p>缺 点：中文文档匮乏。</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="12-apidaora-框架"><a href="#12-apidaora-框架" class="headerlink" title="12. apidaora 框架"></a><a href="#12-apidaora-%E6%A1%86%E6%9E%B6" title="12. apidaora 框架"></a><strong>12. apidaora 框架</strong></h2><p>官 网：</p>
<p><a href="https://github.com/dutradda/apidaora">https://github.com/dutradda/apidaora</a></p>
<p>优 点：使用类型注释将请求 &#x2F; 响应声明为数据类和字典，使用 jsondaora 验证输入数据，最快的 python api 框架之一，可以在任何 asgi 服务器上运行。</p>
<p>缺 点：中文文档匮乏。</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="13-Quixote-框架"><a href="#13-Quixote-框架" class="headerlink" title="13. Quixote 框架"></a><a href="#13-Quixote-%E6%A1%86%E6%9E%B6" title="13. Quixote 框架"></a><strong>13. Quixote 框架</strong></h2><p>官 网：</p>
<p><a href="http://www.quixote.ca/">http://www.quixote.ca/</a></p>
<p>优 点：Quixote 是一个使用 Python 编写基于 Web 的应用程序的框架。它的目标是按此顺序实现灵活性和高性能。Quixote 应用程序的结构往往类似于传统应用程序。格式化网页的逻辑由 Python 类和函数组成。Quixote 不强制分离表示逻辑和 “后端” 逻辑。相反，我们鼓励您使用传统技术。例如，一种解决方案是将表示逻辑放在其自己的子包中。</p>
<p>缺 点：虽然 Quixote 得到积极维护，但发布频率较低。最近开发的重点是修复错误、提高标准合规性和增加 Quixote 的灵活性。</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="14-reahl-框架"><a href="#14-reahl-框架" class="headerlink" title="14. reahl 框架"></a><a href="#14-reahl-%E6%A1%86%E6%9E%B6" title="14. reahl 框架"></a><strong>14. reahl 框架</strong></h2><p>官 网：</p>
<p><a href="https://www.reahl.org/">https://www.reahl.org/</a></p>
<p>优 点：reahl 是一个可以让开发者完全用 Python 语言编写 Web 应用的开放框架，采用 Python 作为唯一开发语言是其最大特色。此外，reahl 提供了相当清晰且简明的开发组建，对于开发一般功能性 Web 系统足够清晰且可行。</p>
<p>缺 点：提供抽象词汇时，无法掌握一些更高级的用户界面效果，目前不允许使用 Sass 构建 Bootstrap 的修改版本，并支持更高级的用户界面模式</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="15-hug-框架"><a href="#15-hug-框架" class="headerlink" title="15. hug 框架"></a><a href="#15-hug-%E6%A1%86%E6%9E%B6" title="15. hug 框架"></a><strong>15. hug 框架</strong></h2><p>官 网：</p>
<p><a href="https://hug.rest/">https://hug.rest/</a></p>
<p>优 点：Hug 是一个 Python 3 API 开发框架。它的设计使软件工程师可以一次开发 API，然后在需要时再使用它。Hug 框架通过提供各种接口来简化 API 开发。这就是为什么该框架被称为 Python 3 中最快的框架之一的主要原因。</p>
<p>缺 点：它使用以前的 WSGI 标准，这是一个同步框架，所以它不能处理像 WebSockets 和其他异步请求，不管怎么说，它仍然有非常好的性能表现。</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_png/iaGGR9eXibkibjc2xlbRh5D0T8OTQYFhT7v74UvLQavzuEJFkBeosPwAWf2s29CEg6GujeX2jUSztYovC6HZsQrpg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1"><img src="https://mmbiz.qpic.cn/mmbiz_png/iaGGR9eXibkibjc2xlbRh5D0T8OTQYFhT7v74UvLQavzuEJFkBeosPwAWf2s29CEg6GujeX2jUSztYovC6HZsQrpg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<h2 id="16-BlackSheep-框架"><a href="#16-BlackSheep-框架" class="headerlink" title="16. BlackSheep 框架"></a><a href="#16-BlackSheep-%E6%A1%86%E6%9E%B6" title="16. BlackSheep 框架"></a><strong>16. BlackSheep 框架</strong></h2><p>官 网：</p>
<p><a href="https://github.com/Neoteroi/BlackSheep">https://github.com/Neoteroi/BlackSheep</a></p>
<p>优 点：BlackSheep 是一个异步 Web 框架，用于使用 Python 构建基于事件的 Web 应用程序。它的灵感来自 Flask、ASP.NET Core 和 Yury Selivanov 的工作。</p>
<p>缺 点：中文文档匮乏。</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_png/iaGGR9eXibkibjc2xlbRh5D0T8OTQYFhT7vYGSFXA48xGBc8Rseoq1BdruQWzGeVQE5DVbkQygQemKdUHmEJU80FA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1"><img src="https://mmbiz.qpic.cn/mmbiz_png/iaGGR9eXibkibjc2xlbRh5D0T8OTQYFhT7vYGSFXA48xGBc8Rseoq1BdruQWzGeVQE5DVbkQygQemKdUHmEJU80FA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<h2 id="17-Index-py-框架"><a href="#17-Index-py-框架" class="headerlink" title="17. Index.py 框架"></a><a href="#17-Index-py-%E6%A1%86%E6%9E%B6" title="17. Index.py 框架"></a><strong>17. Index.py 框架</strong></h2><p>官 网：</p>
<p><a href="https://index-py.aber.sh/stable/">https://index-py.aber.sh/stable/</a></p>
<p>优 点：实现了 ASGI3 接口并使用 Radix Tree 进行路由查找。是最快的 Python web 框架之一。一切特性都服务于快速开发高性能的 Web 服务。大量正确的类型注释，灵活且高效的路由系统，可视化 API 接口与在线调试，支持 Server-sent events 与 WebSocket，自带一键部署命令 (基于 uvicorn 与 gunicorn)，可使用任何可用的 ASGI 生态。</p>
<p>缺 点：Index.py 不内置数据库、缓存等其他功能。选择困难者请直接使用 Django。</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="18-Sanic-框架"><a href="#18-Sanic-框架" class="headerlink" title="18. Sanic 框架"></a><a href="#18-Sanic-%E6%A1%86%E6%9E%B6" title="18. Sanic 框架"></a><strong>18. Sanic 框架</strong></h2><p>官 网：</p>
<p><a href="https://github.com/sanic-org/sanic">https://github.com/sanic-org/sanic</a></p>
<p>优 点：Sanic 是一个 Python 3.7+ web 服务器和 web 框架，它的编写速度很快。它允许使用 Python 3.5 中添加的 async&#x2F;await 语法，这使您的代码无阻塞且快速。该项目的目标是提供一种简单的方法来启动和运行一个高性能的 HTTP 服务器，该服务器易于构建、扩展和最终扩展。</p>
<p>缺 点：就功能方面 Sanic 模仿 Flask，比如通过共享 Blueprints 的概念，微小的子应用程序，允许开发人员在更大的应用程序中拆分和组织其代码。对于光光是数据增删改查 CRUD 应用，Sanic 也不是一个好的选择。</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="19-Starlette-框架"><a href="#19-Starlette-框架" class="headerlink" title="19. Starlette 框架"></a><a href="#19-Starlette-%E6%A1%86%E6%9E%B6" title="19. Starlette 框架"></a><strong>19. Starlette 框架</strong></h2><p>官 网：</p>
<p><a href="https://pypi.org/project/starlette/">https://pypi.org/project/starlette/</a></p>
<p>优 点：Starlette 是一个轻量级的 ASGI 框架 &#x2F; 工具包，非常适合构建性能异步服务，它是生产就绪的，并为您提供以下内容：令人印象深刻的表现。WwbSocket 支持。GraphQL 支持。进程内后台任务。启动和关闭事件。基于请求构建的测试客户端。CORS、GZip、静态文件、流响应。会话和 Cookie 支持。100% 的测试覆盖率。100% 类型注释代码库。零硬依赖。</p>
<p>缺 点：Starlette 提供了所有基本的 Web 微框架功能。但是它不提供自动数据验证，序列化或 API 文档。</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="20-Fastapi-框架"><a href="#20-Fastapi-框架" class="headerlink" title="20. Fastapi 框架"></a><a href="#20-Fastapi-%E6%A1%86%E6%9E%B6" title="20. Fastapi 框架"></a><strong>20. Fastapi 框架</strong></h2><p>官 网：</p>
<p><a href="https://fastapi.tiangolo.com/">https://fastapi.tiangolo.com/</a></p>
<p>优 点：FastAPI 是一个现代、快速（高性能）的 Web 框架，用于基于标准 Python 类型提示使用 Python 3.6+ 构建 API。非常高的性能，与 NodeJS 和 Go 相当（感谢 Starlette 和 Pydantic）。可用的最快的 Python 框架之一。减少大约 40% 的人为（开发人员）引发的错误。简短，简单，直观，健壮。</p>
<p>缺 点：本身不带模板语法，需要安装模板语法</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="21-Responder-框架"><a href="#21-Responder-框架" class="headerlink" title="21. Responder 框架"></a><a href="#21-Responder-%E6%A1%86%E6%9E%B6" title="21. Responder 框架"></a><strong>21. Responder 框架</strong></h2><p>官 网：</p>
<p><a href="https://python-responder.org/">https://python-responder.org/</a></p>
<p>优 点：是 kennethreitz 新开发的一个项目，是一个基于 Python 的 HTTP 服务框架。底层用了 Starlette 的框架，Starlette 是一款轻量级的 ASGI 框架 &#x2F; 工具包， 可以用 Starlette 构建高性能的异步 IO 服务。相对于 Starlette , responder 对开发者更加友好一点。kennethreitz 写了 requests 号称 “HTTP for Humans” 更加清楚这一点。事实上比较下来，responder 也比 Starlette 优雅很多。</p>
<p>缺 点：可能是新项目， 打包还不太完善。就目前版本而言，少许代码还不能正常工作。但接口形式已经定义完毕，期待后面版本会加上去。</p>
<h2 id="22-Molten-框架"><a href="#22-Molten-框架" class="headerlink" title="22. Molten 框架"></a><a href="#22-Molten-%E6%A1%86%E6%9E%B6" title="22. Molten 框架"></a><strong>22. Molten 框架</strong></h2><p>官 网：</p>
<p><a href="https://moltenframework.com/">https://moltenframework.com/</a></p>
<p>优 点：Molten 是一个最小的、可扩展的、快速的和高效的框架，用于使用 Python 构建 HTTP API。计划自动验证请求，代码更容易维护。实例可自动序列化，包含 API 在现实世界中通常要求的各种功能，广泛使用 PEP484 类型提示和 mypy。</p>
<p>缺 点：它没有使用像第三方库（如 Pydantic）提供数据验证，序列化和文档，它有自己的库。因此，这些数据类型定义将不太容易重用。依赖注入系统需要对依赖项进行预注册，并且将基于已声明的类型解决依赖问题。因此，不可能声明多个组件来提供一个特定的类型。</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="23-Clastic-框架"><a href="#23-Clastic-框架" class="headerlink" title="23. Clastic 框架"></a><a href="#23-Clastic-%E6%A1%86%E6%9E%B6" title="23. Clastic 框架"></a><strong>23. Clastic 框架</strong></h2><p>官 网：</p>
<p><a href="https://github.com/mahmoud/clastic">https://github.com/mahmoud/clastic</a></p>
<p>优 点：一个功能强大的 Python Web 框架，可简化显式开发实践，同时消除全局状态。Clastic 是完全用 Python 语言编写的，增强可重用性和可测试性，主动 URL 路由检查，更好地控制应用程序初始化，改进的中间件范例，没有全局状态，ORM 用法，更容易的 WSGI 集成。</p>
<p>缺 点：Clastic 没有构建全局状态；URL 路由规则参数和视图函数签名不匹配，在 Clastic 中，这种不匹配会在构建应用程序时引发异常。</p>
<h2 id="24-Aiohttp-框架"><a href="#24-Aiohttp-框架" class="headerlink" title="24. Aiohttp 框架"></a><a href="#24-Aiohttp-%E6%A1%86%E6%9E%B6" title="24. Aiohttp 框架"></a><strong>24. Aiohttp 框架</strong></h2><p>官 网：</p>
<p><a href="https://docs.aiohttp.org/en/stable/">https://docs.aiohttp.org/en/stable/</a></p>
<p>优 点：用于 asyncio 和 Python 的异步 HTTP 客户端 &#x2F; 服务器。支持客户端和 HTTP 服务器，支持开箱即用的服务器 WebSockets 和客户端 WebSockets，没有回调地狱。Web 服务器具有中间件、信号和可插入路由。</p>
<p>缺 点：根据 RFC 7231 aiohttp 2.0 版本后做了接受 HEAD 请求的调整，使用之前版本并且用 add_ get () 添加的请</p>
<p>求，如果使用 HEAD 方法访问会返回 405。如果处理器会写入很多响应体内容，你可以在执行 HEAD 方法时跳过处理响应体内容以提高执行效率。</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="25-Masonite-框架"><a href="#25-Masonite-框架" class="headerlink" title="25. Masonite 框架"></a><a href="#25-Masonite-%E6%A1%86%E6%9E%B6" title="25. Masonite 框架"></a><strong>25. Masonite 框架</strong></h2><p>官 网：</p>
<p><a href="https://docs.masoniteproject.com/">https://docs.masoniteproject.com/</a></p>
<p>优 点：现代和以开发人员为中心的 Python Web 框架致力于实现实际的 batteries，包括具有许多开箱即用功能的开发人员工具，具有极其可扩展的架构。Masonite 非常适合初学者开发人员进入他们的第一个 Web 应用程序，以及需要充分利用 Masonite 的全部潜力来完成他们的应用程序的经验丰富的开发人员。Masonite 努力实现从安装到部署的快速简便，因此开发人员可以尽可能快速有效地从概念到创建。将其用于您的下一个 SaaS！尝试一次，你就会坠入爱河。</p>
<p>缺 点：对于 Masonite 来说，最大的” 竞争对手” 是 Django, 因为社区正在竭尽全力将框架推向容易，令人愉悦的下一件大事。与 Django 相比，Masonite 仍然是婴儿，期待它未来的表现。</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="26-Quart-框架"><a href="#26-Quart-框架" class="headerlink" title="26. Quart 框架"></a><a href="#26-Quart-%E6%A1%86%E6%9E%B6" title="26. Quart 框架"></a><strong>26. Quart 框架</strong></h2><p>官 网：</p>
<p><a href="https://pgjones.gitlab.io/quart/">https://pgjones.gitlab.io/quart/</a></p>
<p>优 点：Quart 是一个 Python 网络微框架。使用 Quart，您可以呈现和提供 HTML 模板，编写（RESTful）JSON API，服务 WebSockets，流请求和响应数据，几乎可以通过 HTTP 或 WebSocket 协议做任何事情。</p>
<p>缺 点：它仅支持 Python 3.7+。</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="27-Tonberry-框架"><a href="#27-Tonberry-框架" class="headerlink" title="27. Tonberry 框架"></a><a href="#27-Tonberry-%E6%A1%86%E6%9E%B6" title="27. Tonberry 框架"></a><strong>27. Tonberry 框架</strong></h2><p>官 网：</p>
<p><a href="https://github.com/Ayehavgunne/Tonberry">https://github.com/Ayehavgunne/Tonberry</a></p>
<p>优 点：一个符合 ASGI 的 Web 微框架，采用基于类的路由方法。受 CherryPy 的影响但与 asyncio 兼容。一个名为 Qactuar 的配套 ASGI 服务器是从这个目前正在进行的项目中产生的。</p>
<p>缺 点：在使用拉取请求，请使用自动格式化程序 iSort 和 Black 并使用 MyPy 验证代码。这是在不消除某些类型错误的情况下，并不总是可以使 MyPy 完全满意，但是至少尽你所能并谨慎使用注释 `# type: ignore`。最后，尝试，尽可能提供最准确的类型提示。</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="28-cyclone-框架"><a href="#28-cyclone-框架" class="headerlink" title="28. cyclone 框架"></a><a href="#28-cyclone-%E6%A1%86%E6%9E%B6" title="28. cyclone 框架"></a><strong>28. cyclone 框架</strong></h2><p>官 网：</p>
<p><a href="https://cyclone.io/">https://cyclone.io/</a></p>
<p>优 点：Cyclone 是 Python 的 Web 服务器框架，它将 Tornado API 实现为 Twisted 协议。Twisted 是一个事件驱动的 Python 网络编程框架。它是最成熟的非阻塞 I&#x2F;O 库之一，可供公众使用。Tornado 是 FriendFeed 网络服务器的开源版本，它是最流行和最快速的 Python 网络服务器之一，具有用于构建网络应用程序的非常不错的 API。除了丰富的功能集之外，Cyclone 还解决了 C10K 问题。</p>
<p>缺 点：Cyclone 不再支持 python 2.x 。</p>
<h2 id="29-Klein-框架"><a href="#29-Klein-框架" class="headerlink" title="29. Klein 框架"></a><a href="#29-Klein-%E6%A1%86%E6%9E%B6" title="29. Klein 框架"></a><strong>29. Klein 框架</strong></h2><p>官 网：</p>
<p><a href="https://github.com/twisted/klein">https://github.com/twisted/klein</a></p>
<p>优 点：Klein 是一个微框架，用于使用 Python 开发可用于生产的 Web 服务。它是 “微” 的，因为它具有类似于 Bottle 和 Flask 的非常小的 API。它不是 “微”，因为它依赖于标准库之外的东西。这主要是因为它建立在广泛使用和经过良好测试的组件上，如 Werkzeug 和 Twisted。</p>
<p>缺 点：也许有点过时了。</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_png/iaGGR9eXibkibjc2xlbRh5D0T8OTQYFhT7vBnFIibORF9iby60Fibho0SD8w6yruia9Of1jRAUXYAZQsIx6CHvKoVNahA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1"><img src="https://mmbiz.qpic.cn/mmbiz_png/iaGGR9eXibkibjc2xlbRh5D0T8OTQYFhT7vBnFIibORF9iby60Fibho0SD8w6yruia9Of1jRAUXYAZQsIx6CHvKoVNahA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<h2 id="30-nameko-框架"><a href="#30-nameko-框架" class="headerlink" title="30. nameko 框架"></a><a href="#30-nameko-%E6%A1%86%E6%9E%B6" title="30. nameko 框架"></a><strong>30. nameko 框架</strong></h2><p>官 网：</p>
<p><a href="https://github.com/nameko/nameko">https://github.com/nameko/nameko</a></p>
<p>优 点：AMQP RPC 和事件（发布 - 订阅），HTTPGET、POST 和 websockets，CLI 实现简单快速的开发，用于单元和集成测试的实用程序。</p>
<p>缺 点：nameko 微服务出错不会自动打印错误日志，需要加上监控相关的依赖，计算密集型任务导致任务重试。</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_png/iaGGR9eXibkibjc2xlbRh5D0T8OTQYFhT7vwTOiczSh8vsIDoUOAVv04ykVES8IicWhI2mtGorInh5asXf3SicZFygKg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1"><img src="https://mmbiz.qpic.cn/mmbiz_png/iaGGR9eXibkibjc2xlbRh5D0T8OTQYFhT7vwTOiczSh8vsIDoUOAVv04ykVES8IicWhI2mtGorInh5asXf3SicZFygKg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<h2 id="31-CubicWeb-框架"><a href="#31-CubicWeb-框架" class="headerlink" title="31. CubicWeb 框架"></a><a href="#31-CubicWeb-%E6%A1%86%E6%9E%B6" title="31. CubicWeb 框架"></a><strong>31. CubicWeb 框架</strong></h2><p>官 网：</p>
<p><a href="https://www.cubicweb.org/">https://www.cubicweb.org/</a></p>
<p>优 点：CubicWeb 是一种语义 Web 应用程序框架，在 LGPL 下获得许可，它使开发人员能够通过重用组件（称为立方体）并遵循众所周知的面向对象设计原则来有效地构建 Web 应用程序。满足常见需求的可重用组件（数据模型和视图）库，Python 编程语言的强大功能和灵活性，用于存储后端的 SQL 数据库、LDAP 目录、Subversion 和 Mercurial 的可靠性。</p>
<p>缺 点：要在 CubicWeb 应用程序中获取或操作持久数据，可以使用关系查询语言（RQL），RQL 提供了一种高度分离的路径来相互关联各种数据源。但是，随着它的实现，通过手动构建查询作为字符串，它可能会让习惯于 ORM 的开发人员感到过时。使用 CubicWeb 还有其他障碍。首先，设置可能很麻烦。另一个潜在的问题是缺少本机模板引擎；生成 HTML 留给开发人员。CubicWeb 支持 Python 3，但 Twisted 等模块本身并未完全移植。</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="32-Zope2-框架"><a href="#32-Zope2-框架" class="headerlink" title="32. Zope2 框架"></a><a href="#32-Zope2-%E6%A1%86%E6%9E%B6" title="32. Zope2 框架"></a><strong>32. Zope2 框架</strong></h2><p>官 网：</p>
<p><a href="https://zope.readthedocs.io/en/latest/">https://zope.readthedocs.io/en/latest/</a></p>
<p>优 点：Zope 2 是一款基于 Python 的 Web 应用框架，是所有 Python Web 应用程序、工具的鼻祖，是 Python 家族一个强有力的分支。Zope 2 的 “对象发布” 系统非常适合面向对象开发方法，并且可以减轻开发者的学习曲线，还可以帮助你发现应用程序里一些不好的功能。</p>
<p>缺 点：Zope 不适用于简单的 RESTful API（每 Bottle 或 Flask），甚至不适用于具有交互性的基本网站（à la Django），由于 Zope 的尺寸和复杂性，安装需要一些工作；这不是简单地将源解压缩到项目子文件夹中的问题。</p>
<h2 id="33-Web2py-框架"><a href="#33-Web2py-框架" class="headerlink" title="33. Web2py 框架"></a><a href="#33-Web2py-%E6%A1%86%E6%9E%B6" title="33. Web2py 框架"></a><strong>33. Web2py 框架</strong></h2><p>官 网：</p>
<p><a href="http://web2py.com/">http://web2py.com/</a></p>
<p>优 点：Web2py 是一个用 Python 语言编写的免费的开源 Web 框架，旨在敏捷快速的开发 Web 应用，具有快速、可扩展、安全以及可移植的数据库驱动的应用，遵循 LGPLv3 开源协议。Web2py 提供一站式的解决方案，整个开发过程都可以在浏览器上进行，提供了 Web 版的在线开发，HTML 模版编写，静态文件的上传，数据库的编写的功能。其它的还有日志功能，以及一个自动化的 admin 接口。</p>
<p>缺 点：Web2py 的一个重要限制是它仅与 Python 2.x 兼容。首先，这意味着 Web2py 无法使用 Python 3 的异步语法。如果你依赖于 Python 3 独有的外部库，那么你就不走运了。但是，正在开展使 Web2py Python 3 兼容的工作，并且在撰写本文时它已接近完成</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="34-Pylons-框架"><a href="#34-Pylons-框架" class="headerlink" title="34. Pylons 框架"></a><a href="#34-Pylons-%E6%A1%86%E6%9E%B6" title="34. Pylons 框架"></a><strong>34. Pylons 框架</strong></h2><p>官 网：</p>
<p><a href="https://docs.pylonsproject.org/projects/pylons-webframework/en/latest/">https://docs.pylonsproject.org/projects/pylons-webframework/en/latest/</a></p>
<p>优 点：Pylons 是一个开放源代码的 Web 应用框架，使用 python 语言编写。它对 WSGI 标准进行了扩展应用，提升了重用性且将功能分割到独立的模块中。Pylons 是最新的 Web 应用框架中的典型，类似于 Django 和 TurboGears。Pylons 受 Ruby on Rails 影响很深：它的两个组件，Routes 和 WebHelpers 是 Rails 特性的 Python 实现。</p>
<p>缺 点：Pylons 已与 repoze.bfg 合并，现在处于仅维护模式。强烈建议新项目从新合并的 Web 框架金字塔开始。</p>
<p>![Image](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="35-Cubes-框架"><a href="#35-Cubes-框架" class="headerlink" title="35. Cubes 框架"></a><a href="#35-Cubes-%E6%A1%86%E6%9E%B6" title="35. Cubes 框架"></a><strong>35. Cubes 框架</strong></h2><p>官 网：</p>
<p><a href="https://pythonhosted.org/cubes/">https://pythonhosted.org/cubes/</a></p>
<p>优 点：Cubes 是一个轻量级的 Python 框架和工具集，用于开发报告和分析应用程序、在线分析处理 (OLAP)、多维分析和浏览聚合数据。它是 Data Brewery 的一部分。</p>
<p>缺点：不再为每个多维数据集提供隐式聚合 record_count。它必须明确定义为聚合：旧的后端架构是有限制的。它只允许使用一个商店，必须在服务器启动之前知道模型，不可能从远程来源获取模型。</p>
<h2 id="36-Dpark-框架"><a href="#36-Dpark-框架" class="headerlink" title="36. Dpark 框架"></a><a href="#36-Dpark-%E6%A1%86%E6%9E%B6" title="36. Dpark 框架"></a><strong>36. Dpark 框架</strong></h2><p>官 网：</p>
<p><a href="https://github.com/Liangchengdeye/Dpark">https://github.com/Liangchengdeye/Dpark</a></p>
<p>优 点：DPark 是 Spark 的 Python 克隆版本，是一个 Python 实现的分布式计算框架，可以非常方便地实现大规模数据处理和低延时的迭代计算。该计算框架类似于 MapReduce，但是比其更灵活，可以用 Python 非常方便地进行分布式计算，并且提供了更多的功能，以便更好地进行迭代式计算。DPark 由国内的豆瓣公司开发实现和负责维护，据豆瓣公司的描述，目前豆瓣公司内部的绝大多数数据分析都使用 DPark 完成，整个项目也正趋于完善。</p>
<p>缺 点：Dpark 使用的是进程，在 Python 中，由于 GIL (Global Interpreter Lock) 的存在，即使在多核机器上使用多个线程，这些线程之间也没有办法真正地实现并发执行。</p>
<h2 id="37-Buildbot-框架"><a href="#37-Buildbot-框架" class="headerlink" title="37. Buildbot 框架"></a><a href="#37-Buildbot-%E6%A1%86%E6%9E%B6" title="37. Buildbot 框架"></a><strong>37. Buildbot 框架</strong></h2><p>官 网：</p>
<p><a href="https://buildbot.python.org/all/#/">https://buildbot.python.org/all/#/</a></p>
<p>优 点：Buildbot 是 python 实现的开源持续构建和持续交付工具，为 Python, Mozilla, Chromium, WebKit 等知名项目使用。Buildbot 可以直接使用 python 包，轻松拥有上万库，具备强大的扩展能力。如果你觉得 Jenkins 已经轻松地满足你的需求，你不需要 Buildbot。如果你在 Jenkins 时觉得效率低下、扩展困难、一些用 python 等脚本可以实现的动作在 Jenkins 困难重重，那么可以看看 Buildbot。</p>
<p>缺 点：buildbot 对多项目支持并不好。</p>
<p>引用链接：<a href="https://mp.weixin.qq.com/s/0b_bG83S-LEpQOtaWZXv3A">https://mp.weixin.qq.com/s/0b_bG83S-LEpQOtaWZXv3A</a></p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>澳洲家中日常必备清单</title>
    <url>/studyz.github.io/2022/05/19/2023_03_22_%E6%BE%B3%E6%B4%B2%E5%AE%B6%E4%B8%AD%E6%97%A5%E5%B8%B8%E5%BF%85%E5%A4%87%E6%B8%85%E5%8D%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1⃣️ CEPACAINE漱口水！ 治疗牙龈肿痛，口腔溃疡。澳洲医生推荐买的，超级有效！猫猫家必备的，再也没有牙口烦恼。 购买地址：Chemist有售 💰价格：$15.49 问题在口腔，吃啥啥不香，买它！喵～</p>
<hr>
<p>2⃣️ Quick EZE胃糖 腹胀、胃酸、胃痛。消化不良、吃颗糖就能缓解～ 主要是这糖咋还那么好吃！ 购买地址：Chemist 💰价格：$4.99 胃也需要轻轻安抚，买它！喵～</p>
<hr>
<p>3⃣️ VICKS 通鼻喷剂 在澳洲总感觉鼻子不适，鼻炎老犯，尤其总是鼻塞。这个通鼻喷剂起效快，薄荷味柔和不刺激。 购买地址：Chemist 💰价格$11.99 杜绝张口呼吸，买它！喵～</p>
<hr>
<p>4⃣️ Refresh眼药水 在家学习、工作、打游戏、熬夜，眼睛干涩的话最使用用人工泪液成分的眼药水。无刺激，缓解眼睛疲劳，闺蜜们都在用。 购买地址：Chemist 💰价格$13.49 缓解就靠累上加泪。买它，喵～</p>
<hr>
<p>5⃣️ LeQure Detox Soap排毒香皂 这款味道超级淡，小众然鹅超棒！主要可以用来控油去杂质。背部长痘痘的宝宝们一定要试试。滋养加排毒，姐妹推荐的，用过也感觉很好。 购买地址：Chemist 💰价格：$5.99 永远不进毒圈，买它，喵～</p>
<hr>
<p>6⃣️ Naprogesic止痛片 姨妈期最好的止痛片咯，因为成分对胃损伤小，刺激小。而且止痛的效果起效更快，当地女生首选经期续命药。小蓝片好多朋友都在用。 购买地址：Chemist 💰价格：$7.99 连我姨妈都在用！买它，喵～</p>
<hr>
<p>7⃣️ Dettol 洗衣消毒液 家里养宠物的朋友洗衣服都会用这个帮忙杀菌！能灭杀99.9%的细菌。尤其是合租又共用洗衣机的话这个肯定要买！ 购买地址：Coles、 WWS有售 💰价格：$8.99 再也不怕室友用洗衣机洗袜子了，买它！喵～</p>
<hr>
<p>8⃣️ Mr muscle通道强力剂！ 水槽，浴室如果都便秘了，那主人可就更难受了。 超强清下水道秘方，家家必备的男人。尤其是掉头发比较多的女生经常会堵掉下水道。用它就可以畅通哦。 购买地址：Coles、WWS有售 💰价格：$13.7 搞定下水道，心情好到爆，买它！喵～</p>
<hr>
]]></content>
      <tags>
        <tag>推荐</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>AI创建视频脚本提示词</title>
    <url>/studyz.github.io/2022/06/19/2023_03_23_How%20to%20use%20ChatGPT%20to%20create%20Awesome%20Video%20Scripts/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="English-Version"><a href="#English-Version" class="headerlink" title="English Version"></a>English Version</h2><p>Step 1: <code>Find Videos that are already successful.</code><br>Step 2: <code>Copy the transcript from the video</code><br>Step 3: Can you make 10 YouTube video titles based on this video script? make these titles more thought-provoking and more clickable and add curiosity.reply in chinese<br>Step 4: Can you write me a short video script for this video titles? reply in chinese<br>Step 5: Can you write me a description for this video title? reply in chinese<br>Step 6: Can you write me a youtube video shooting script based on this video description? reply in chinese</p>
<h2 id="中文翻译"><a href="#中文翻译" class="headerlink" title="中文翻译"></a>中文翻译</h2><p>Step 1: <code>寻找已有成功的视频。</code><br>Step 2: <code>复制视频的脚本。</code><br>Step 3: 能否为这个视频脚本生成10个YouTube视频标题？这些标题应该更加发人深思，并且更加吸引人，同时添加好奇心。回复中文<br>Step 4: 能否为这些视频标题编写一个短的视频脚本？回复中文<br>Step 5: 能否为这些视频标题编写一个描述？回复中文<br>Step 6: 能否为这个视频描述编写一个YouTube视频射击脚本？回复中文</p>
]]></content>
      <tags>
        <tag>GPT</tag>
        <tag>AI</tag>
        <tag>视频创作</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop、Spark、Flink简单概要</title>
    <url>/studyz.github.io/2022/06/23/2023_03_28_Hadoop%E3%80%81Spark%E3%80%81Flink%E7%AE%80%E5%8D%95%E6%A6%82%E8%A6%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://zhuanlan.zhihu.com/p/526462792">Hadoop用于离线复杂大数据处理</a></p>
<p>Spark 用于离线快速的大数据处理</p>
<p>Flink 用于在线实时的大数据处理</p>
<h1 id="1-数据处理"><a href="#1-数据处理" class="headerlink" title="1-数据处理"></a>1-数据处理</h1><p>Hadoop：为批处理而构建的Hadoop，它一次性在输入中获取大量数据集，对其进行处理并产生结果。批处理在处理大量数据时非常有效。由于数据的大小和系统的计算能力，输出会出现延迟。</p>
<p>Spark：Spark也是 Hadoop生态系统的一部分。它本质上也是一个批处理系统，但它也支持流处理。</p>
<p>Flink：Flink为流式处理和批处理提供了单一的运行时。</p>
<h1 id="2-流引擎"><a href="#2-流引擎" class="headerlink" title="2-流引擎"></a>2-流引擎</h1><p>Hadoop：Map-reduce是面向批处理的工具。它一次性在输入中获取大量数据集，对其进行处理并产生结果。</p>
<p>Spark：Apache Spark Streaming以微批处理的形式处理数据流。每个批次都包含在批次期间到达的事件集合。但对于我们需要处理大量实时数据流并实时提供结果的用例来说，这还不够。</p>
<p>Flink：Apache Flink是真正的流媒体引擎。它使用流来处理工作负载：流式处理、SQL、微批处理和批处理。批处理是一组有限的流数据。</p>
<h1 id="3-数据流"><a href="#3-数据流" class="headerlink" title="3-数据流"></a>3-数据流</h1><p>Hadoop：MapReduce计算数据流没有任何循环。这是一个阶段链，在每个阶段，您都使用前一阶段的输出向前推进，并为下一阶段产生输入。</p>
<p>Spark：虽然机器学习算法是一个循环数据流，但 Spark将其表示为（DAG）有向无环图。</p>
<p>Flink：Flink采用了与其他方法不同的方法。它在运行时支持受控循环依赖图。这有助于以非常有效的方式表示机器学习算法。</p>
<h1 id="4-计算模型"><a href="#4-计算模型" class="headerlink" title="4-计算模型"></a>4-计算模型</h1><p>Hadoop：MapReduce采用了面向批处理的模型，批处理正在处理静态数据，一次需要大量数据，对其进行处理，然后写出输出。</p>
<p>Spark：Spark采用了微批处理。微批次本质上是一种“收集然后处理”的计算模型。</p>
<p>Flink：Flink采用了连续流、基于算子的流模型。连续流算子在数据到达时对其进行处理，而不会延迟收集数据或处理数据。</p>
<h1 id="5-性能"><a href="#5-性能" class="headerlink" title="5-性能"></a>5-性能</h1><p>Hadoop：Apache Hadoop仅支持批处理。它不处理流数据，因此与Hadoop、Spark和Flink相比，性能更慢。</p>
<p>Spark：虽然Spark有优秀的社区背景，并且现在被认为是最成熟的社区，但它的流处理效率并不比Flink高，因为它使用的是微批处理。</p>
<p>Flink：与任何其他数据处理系统相比，Flink的性能非常出色。比较Hadoop、Spark和Flink时可以看出，Flink使用原生闭环迭代运算符，这使得机器学习和图形处理更快。</p>
<h1 id="6-内存管理"><a href="#6-内存管理" class="headerlink" title="6-内存管理"></a>6-内存管理</h1><p>Hadoop：提供可配置的内存管理，可以动态或静态地执行此操作。</p>
<p>Spark：提供可配置的内存管理，Spark 1.6 的最新版本已经朝着自动化内存管理的方向发展。</p>
<p>Flink：提供了自动内存管理，有自己的内存管理系统。</p>
<h1 id="7-容错"><a href="#7-容错" class="headerlink" title="7-容错"></a>7-容错</h1><p>Hadoop：MapReduce具有高度容错性。如果Hadoop出现任何故障，则无需从头开始重新启动应用程序。</p>
<p>Spark：Apache Spark Streaming恢复丢失的工作，无需额外的代码或配置。</p>
<p>Flink：Apache Flink遵循的容错机制是基于Chandy-Lamport分布式快照。该机制是轻量级的，导致在保持高吞吐率的同时提供强大的一致性保证。</p>
<h1 id="8-可扩展性"><a href="#8-可扩展性" class="headerlink" title="8-可扩展性"></a>8-可扩展性</h1><p>Hadoop：MapReduce具有很强的可扩展性潜力，并已在数万个节点上用于生产。</p>
<p>Spark：它具有高度可扩展性，我们可以在集群中不断添加 n 个节点，一个已知的大型 Spark集群有8000个节点。</p>
<p>Flink：Flink也具有很高的可扩展性，我们可以在集群中不断添加 n 个节点，一个已知的大型 Flink 集群有数千个节点。</p>
<h1 id="9-迭代处理"><a href="#9-迭代处理" class="headerlink" title="9-迭代处理"></a>9-迭代处理</h1><p>Hadoop：不支持迭代处理。</p>
<p>Spark：它批量迭代其数据。在Spark中，每次迭代都必须单独安排和执行。</p>
<p>Flink：它通过使用其流式架构来迭代数据。可以指示Flink只处理实际发生变化的部分数据，从而显着提高作业的性能。</p>
<h1 id="10-语言支持"><a href="#10-语言支持" class="headerlink" title="10-语言支持"></a>10-语言支持</h1><p>Hadoop：主要支持Java，其他支持的语言有c、c++、ruby、groovy、Perl、Python。</p>
<p>Spark：支持Java、Scala、Python和R。Spark是在Scala中实现的，供其他语言的API，如Java、Python和 R。</p>
<p>Flink：支持 Java、Scala、Python和R。Flink 是用 Java实现的，同时也提供了Scala API。</p>
<h1 id="11-优化"><a href="#11-优化" class="headerlink" title="11-优化"></a>11-优化</h1><p>Hadoop：在 MapReduce 中，作业必须手动优化。有几种方法可以优化MapReduce作业：正确配置集群、使用组合器、使用LZO压缩、适当调整 MapReduce任务的数量以及为数据使用最合适和最紧凑的可写类型。</p>
<p>Spark：在Spark中，作业必须手动优化。有一个新的可扩展优化器 Catalyst，它基于Scala中的函数式编程结构。 Catalyst 的可扩展设计有两个目的：第一，易于添加新的优化技术。其次，使外部开发人员能够扩展优化器催化剂。</p>
<p>Flink：Apache Flink带有一个独立于实际编程接口的优化器。 Flink优化器的工作方式类似于关系数据库优化器，但将这些优化应用于Flink程序，而不是 SQL查询。</p>
<h1 id="12-延迟"><a href="#12-延迟" class="headerlink" title="12-延迟"></a>12-延迟</h1><p>Hadoop：Hadoop的MapReduce框架相对较慢，因为它旨在支持不同的格式、结构和海量数据。这就是为什么 Hadoop的延迟比Spark和Flink都高。</p>
<p>Spark：Spark是另一个批处理系统，但它比Hadoop MapReduce相对快，因为它通过RDD将大部分输入数据缓存在内存中，并将中间数据保存在内存中，最终在完成或需要时将数据写入磁盘。</p>
<p>Flink：Flink的数据流运行时只需少量配置，即可实现低延迟和高吞吐量。</p>
<h1 id="14-可视化"><a href="#14-可视化" class="headerlink" title="14-可视化"></a>14-可视化</h1><p>Hadoop：在Hadoop中，数据可视化工具是zoomdata，它可以直接连接到HDFS以及SQL-on-Hadoop技术，如 Impala、Hive、Spark SQL、Presto等。</p>
<p>Spark：它提供了一个用于提交和执行作业的Web界面，在该界面上可以可视化生成的执行计划。 Flink和Spark都集成到Apache zeppelin中，它提供数据分析、摄取以及发现、可视化和协作。</p>
<p>Flink：它还提供了一个用于提交和执行作业的Web界面，生成的执行计划可以在这个界面上进行可视化。</p>
<h1 id="15-恢复"><a href="#15-恢复" class="headerlink" title="15-恢复"></a>15-恢复</h1><p>Hadoop：MapReduce自然地对系统故障或故障具有弹性。它是高度容错的系统。</p>
<p>Spark：Apache Spark RDD允许通过重新计算DAG来恢复故障节点上的分区，同时还通过检查点支持与Hadoop更相似的恢复方式，以减少RDD的依赖关系。</p>
<p>Flink：支持checkpointing机制，将程序存储在数据源和数据接收器中，窗口的状态，以及用户自定义的状态，在失败后恢复流式作业。</p>
<h1 id="16-安全性"><a href="#16-安全性" class="headerlink" title="16-安全性"></a>16-安全性</h1><p>Hadoop：它支持Kerberos身份验证，管理起来有些麻烦。但是，第三方供应商已使组织能够利用Active Directory Kerberos和LDAP进行身份验证。</p>
<p>Spark：Apache Spark的安全性有点稀疏，目前仅支持通过共享密钥（密码身份验证）进行身份验证。 当你在HDFS上运行Spark，它可以使用HDFS ACL和文件级权限。此外，Spark可以在 YARN上运行以使用Kerberos身份验证。</p>
<p>Flink：Flink通过Hadoop &#x2F; Kerberos基础设施支持用户身份验证。如果在YARN上运行Flink，Flink会获取提交程序的用户的Kerberos令牌，并使用该令牌在YARN、HDFS和HBase上进行身份验证。Flink即将推出的连接器，流程序可以通过 SSL将自己验证为流代理。</p>
<h1 id="17-成本"><a href="#17-成本" class="headerlink" title="17-成本"></a>17-成本</h1><p>Hadoop：MapReduce通常可以在比某些替代方案更便宜的硬件上运行，因为它不会尝试将所有内容都存储在内存中。</p>
<p>Spark：由于Spark需要大量RAM才能在内存中运行，因此在集群中增加它会逐渐增加其成本。</p>
<p>Flink：Apache Flink也需要大量的RAM在内存中运行，所以它的成本会逐渐增加。</p>
<h1 id="18-兼容性"><a href="#18-兼容性" class="headerlink" title="18-兼容性"></a>18-兼容性</h1><p>Hadoop：Apache Hadoop MapReduce 和 Apache Spark相互兼容，Spark通过JDBC和ODBC共享MapReduce 对数据源、文件格式和商业智能工具的所有兼容性。</p>
<p>Spark：Apache Spark和Hadoop相互兼容。 Spark与Hadoop数据兼容。它可以通过YARN或Spark的独立模式在 Hadoop集群中运行，并且可以处理HDFS、HBase、Cassandra、Hive和任何Hadoop InputFormat中的数据。</p>
<p>Flink：Apache Flink是一个可扩展的数据分析框架，完全兼容Hadoop。它提供了一个Hadoop Compatibility包来包装针对Hadoop的MapReduce接口实现的函数，并将它们嵌入到Flink程序中。</p>
<h1 id="20-使用感"><a href="#20-使用感" class="headerlink" title="20-使用感"></a>20-使用感</h1><p>Hadoop：MapReduce 开发人员需要手动编写每个操作的代码，这让编程工作变得非常困难。</p>
<p>Spark：很容易编程，因为它有大量的高级操作符。</p>
<p>Flink：也有高级算子，易于操作。</p>
<h1 id="21-交互模式"><a href="#21-交互模式" class="headerlink" title="21-交互模式"></a>21-交互模式</h1><p>Hadoop：MapReduce 没有交互模式。</p>
<p>Spark：Spark 有一个交互式Shell，可以学习如何充分利用Spark。这是一个用 Scala编写的Spark应用程序，提供一个具有自动完成功能的命令行环境，您可以在其中运行临时查询并熟悉 Spark的功能。</p>
<p>Flink：它带有一个集成的交互式Scala Shell。它可以在本地设置和集群设置中使用。</p>
<h1 id="22-实时分析"><a href="#22-实时分析" class="headerlink" title="22-实时分析"></a>22-实时分析</h1><p>Hadoop：MapReduce 在实时数据处理方面失败了，因为它旨在对大量数据执行批处理。</p>
<p>Spark：它可以处理实时数据，即以每秒数百万个事件的速率来自实时事件流的数据。</p>
<p>Flink：主要用于实时数据分析，虽然也提供了快速的批量数据处理。</p>
<h1 id="23-调度器"><a href="#23-调度器" class="headerlink" title="23-调度器"></a>23-调度器</h1><p>Hadoop：Hadoop中的调度程序成为可插拔组件。多用户工作负载有两个调度器：公平调度器和容量调度器。为了调度复杂的流程，MapReduce需要像Oozie这样的外部作业调度程序。</p>
<p>Spark：由于内存计算，Spark能充当自己的流调度程序。</p>
<p>Flink：Flink可以使用YARN Scheduler，Flink也有自己的 Scheduler。</p>
<h1 id="24-SQL支持"><a href="#24-SQL支持" class="headerlink" title="24-SQL支持"></a>24-SQL支持</h1><p>Hadoop：它使用户能够使用 Apache Hive运行SQL查询。</p>
<p>Spark：它使用户能够使用Spark-SQL运行SQL查询。Spark提供了类似Hives的查询语言和类似DSL的Dataframe 来查询结构化数据。</p>
<p>Flink：在Flink中，Table API是一种类似SQL的表达式语言，支持DSL等数据帧，目前仍处于测试阶段。有计划添加SQL接口，但不确定何时会进入框架。</p>
<h1 id="25-缓存"><a href="#25-缓存" class="headerlink" title="25-缓存"></a>25-缓存</h1><p>Hadoop：MapReduce 无法将数据缓存在内存中以满足未来需求。</p>
<p>Spark：它可以将数据缓存在内存中以进行进一步的迭代，从而提高其性能。</p>
<p>Flink：它可以将数据缓存在内存中以供进一步迭代以提高其性能。</p>
<h1 id="26-硬件要求"><a href="#26-硬件要求" class="headerlink" title="26-硬件要求"></a>26-硬件要求</h1><p>Hadoop：MapReduce在商品硬件上运行良好。</p>
<p>Spark：Apache Spark需要中高级硬件。由于Spark将数据缓存在内存中以供进一步迭代，从而提高其性能。</p>
<p>Flink：Apache Flink也需要中高级硬件。 Flink还可以将数据缓存在内存中以进行进一步的迭代，从而提高其性能。</p>
<h1 id="27-机器学习"><a href="#27-机器学习" class="headerlink" title="27-机器学习"></a>27-机器学习</h1><p>Hadoop：需要像Apache Mahout这样的机器学习工具。</p>
<p>Spark：有自己的一套机器学习MLlib。在内存缓存和其他实现细节中，它确实是实现ML算法的强大平台。</p>
<p>Flink：有FlinkML，它是Flink的机器学习库。它支持运行时受控的循环依赖图。与DAG表示相比，这使得它们以非常有效的方式表示ML算法。</p>
<h1 id="28-部署"><a href="#28-部署" class="headerlink" title="28-部署"></a>28-部署</h1><p>Hadoop：在独立模式下，Hadoop 被配置为在单节点、非分布式模式下运行。在伪分布式模式下，Hadoop以伪分布式模式运行。因此，不同之处在于每个Hadoop守护程序以伪分布式模式在单独的Java进程中运行。而在本地模式下，每个Hadoop守护程序都作为单个Java进程运行。在完全分布式模式下，所有守护进程在单独的节点中执行，形成一个多节点集群。</p>
<p>Spark：还提供了一种简单的独立部署模式，可以在Mesos或YARN集群管理器上运行。它可以手动启动，通过手动启动 master和worker或使用我们提供的启动脚本。也可以在单台机器上运行这些守护进程进行测试。</p>
<p>Flink：还提供了在YARN集群管理器上运行的独立部署模式。</p>
<h1 id="29-消除重复"><a href="#29-消除重复" class="headerlink" title="29-消除重复"></a>29-消除重复</h1><p>Hadoop：Hadoop中没有重复消除。</p>
<p>Spark：Spark还对每条记录进行一次准确的处理，因此消除了重复。</p>
<p>Flink：Flink只处理一次记录，因此消除了重复，流应用程序可以在计算期间保持自定义状态。Flink的检查点机制确保在出现故障时状态的语义恰好只有一次。</p>
<h1 id="30-Window标准"><a href="#30-Window标准" class="headerlink" title="30-Window标准"></a>30-Window标准</h1><p>一个数据流需要被分成许多逻辑流，每个逻辑流都可以应用一个窗口操作符。</p>
<p>Hadoop：不支持流式传输，因此不需要窗口条件。</p>
<p>Spark：具有基于时间的窗口标准。</p>
<p>Flink：具有基于记录的或任何自定义的用户定义的Flink Window标准。  </p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>统计分析的八种方法</title>
    <url>/studyz.github.io/2022/06/29/2023_03_30_%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E7%9A%84%E5%85%AB%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、指标对比分析法"><a href="#一、指标对比分析法" class="headerlink" title="一、指标对比分析法"></a>一、指标对比分析法</h1><p>指标对比分析法，又称比较分析法，是统计分析中最常用的方法。是通过有关的指标对比来反映事物数量上差异和变化的方法。有比较才能鉴别。单独看一些指标，只能说明总体的某些数量特征，得不出什么结论性的认识；一经过比较，如与国外、外单位比，与历史数据比，与计划相比，就可以对规模大小、水平高低、速度快慢作出判断和评价。</p>
<p>指标分析对比分析方法可分为静态比较和动态比较分析。静态比较是同一时间条件下不同总体指标比较，如不同部门、不同地区、不同国家的比较，也叫横向比较；动态比较是同一总体条件不同时期指标数值的比较，也叫纵向比较。这两种方法既可单独使用，也可结合使用。进行对比分析时，可以单独使用总量指标或相对指标或平均指标，也可将它们结合起来进行对比。比较的结果可用相对数，如百分数、倍数、系数等，也可用相差的绝对数和相关的百分点（每1％为一个百分点）来表示，即将对比的指标相减。</p>
<h1 id="二、分组分析法"><a href="#二、分组分析法" class="headerlink" title="二、分组分析法"></a>二、分组分析法</h1><p>指标对比分析法是总体上的对比，但组成统计总体的各单位具有多种特征，这就使得在同一总体范围内的各单位之间产生了许多差别，统计分析不仅要对总体数量特征和数量关系进行分析，还要深入总体的内部进行分组分析。分组分析法就是根据统计分析的目的要求，把所研究的总体按照一个或者几个标志划分为若干个部分，加以整理，进行观察、分析，以揭示其内在的联系和规律性。</p>
<p>统计分组法的关键问题在于正确选择分组标值和划分各组界限。</p>
<h1 id="三、时间数列及动态分析法"><a href="#三、时间数列及动态分析法" class="headerlink" title="三、时间数列及动态分析法"></a>三、时间数列及动态分析法</h1><p>时间数列。是将同一指标在时间上变化和发展的一系列数值，按时间先后顺序排列，就形成时间数列，又称动态数列。它能反映社会经济现象的发展变动情况，通过时间数列的编制和分析，可以找出动态变化规律，为预测未来的发展趋势提供依据。时间数列可分为绝对数时间数列、相对数时间数列、平均数时间数列。</p>
<p>时间数列速度指标。根据绝对数时间数列可以计算的速度指标：有发展速度、增长速度、平均发展速度、平均增长速度。</p>
<p>动态分析法。在统计分析中，如果只有孤立的一个时期指标值，是很难作出判断的。如果编制了时间数列，就可以进行动态分析，反映其发展水平和速度的变化规律。</p>
<p>进行动态分析，要注意数列中各个指标具有的可比性。总体范围、指标计算方法、计算价格和计量单位，都应该前后一致。时间间隔一般也要一致，但也可以根据研究目的，采取不同的间隔期，如按历史时期分。为了消除时间间隔期不同而产生的指标数值不可比，可采用年平均数和年平均发展速度来编制动态数列。此外在统计上，许多综合指标是采用价值形态来反映实物总量，如国内生产总值、工业总产值、社会商品零售总额等计算不同年份的发展速度时，必须消除价格变动因素的影响，才能正确的反映实物量的变化。也就是说必须用可比价格（如用不变价或用价格指数调整）计算不同年份相同产品的价值，然后才能进行对比。</p>
<p>为了观察我国经济发展的波动轨迹，可将各年国内生产总值的发展速度编制时间数列，并据以绘制成曲线图，令人得到直观认识。</p>
<h1 id="四、指数分析法"><a href="#四、指数分析法" class="headerlink" title="四、指数分析法"></a>四、指数分析法</h1><p>指数是指反映社会经济现象变动情况的相对数。有广义和狭义之分。根据指数所研究的范围不同可以有个体指数、类指数与总指数之分。</p>
<p>指数的作用：一是可以综合反映复杂的社会经济现象的总体数量变动的方向和程度；二是可以分析某种社会经济现象的总变动受各因素变动影响的程度，这是一种因素分析法。操作方法是：通过指数体系中的数量关系，假定其他因素不变，来观察某一因素的变动对总变动的影响。</p>
<p>用指数进行因素分析。因素分析就是将研究对象分解为各个因素，把研究对象的总体看成是各因素变动共同的结果，通过对各个因素的分析，对研究对象总变动中各项因素的影响程度进行测定。因素分析按其所研究的对象的统计指标不同可分为对总量指标的变动的因素分析，对平均指标变动的因素分析。</p>
<h1 id="五、平衡分析法"><a href="#五、平衡分析法" class="headerlink" title="五、平衡分析法"></a>五、平衡分析法</h1><p>平衡分析是研究社会经济现象数量变化对等关系的一种方法。它把对立统一的双方按其构成要素一一排列起来，给人以整体的概念，以便于全局来观察它们之间的平衡关系。平衡关系广泛存在于经济生活中，大至全国宏观经济运行，小至个人经济收支。平衡种类繁多，如财政平衡表、劳动力平衡表、能源平衡表、国际收支平衡表、投入产出平衡表，等等。平衡分析的作用：一是从数量对等关系上反映社会经济现象的平衡状况，分析各种比例关系相适应状况；二是揭示不平衡的因素和发展潜力；三是利用平衡关系可以从各项已知指标中推算未知的个别指标。</p>
<h1 id="六、综合评价分析"><a href="#六、综合评价分析" class="headerlink" title="六、综合评价分析"></a>六、综合评价分析</h1><p>社会经济分析现象往往是错综复杂的，社会经济运行状况是多种因素综合作用的结果，而且各个因素的变动方向和变动程度是不同的。如对宏观经济运行的评价，涉及生活、分配、流通、消费各个方面；对企业经济效益的评价，涉及人、财、物合理利用和市场销售状况。如果只用单一指标，就难以作出恰当的评价。</p>
<p>进行综合评价包括四个步骤：</p>
<p>（一）确定评价指标体系，这是综合评价的基础和依据。要注意指标体系的全面性和系统性。</p>
<p>（二）搜集数据，并对不同计量单位的指标数值进行同度量处理。可采用相对化处理、函数化处理、标准化处理等方法。</p>
<p>（三）确定各指标的权数，以保证评价的科学性。根据各个指标所处的地位和对总体影响程度不同，需要对不同指标赋予不同的权数。</p>
<p>（四）对指标进行汇总，计算综合分值，并据此作出综合评价。</p>
<h1 id="七、景气分析经济波动是客观存在的，是任何国家都难以完全避免的"><a href="#七、景气分析经济波动是客观存在的，是任何国家都难以完全避免的" class="headerlink" title="七、景气分析经济波动是客观存在的，是任何国家都难以完全避免的"></a>七、景气分析经济波动是客观存在的，是任何国家都难以完全避免的</h1><p>如何避免大的经济波动，保持经济的稳定发展，一直是各国政府和经济之专家在宏观调控和决策中面临的重要课题，景气分析正是适应这一要求而产生和发展的。景气分析是一种综合评价分析，可分为宏观经济景气分析和企业景气调查分析。</p>
<p>宏观经济景气分析。是国家统计局20世纪80年代后期开始着手建立监测指标体系和评价方法，经过十多年时间和不断完善，已形成制度，定期提供景气分析报告，对宏观经济运行状态起到晴雨表和报警器的作用，便于国务院和有关部门及时采取宏观调控措施。以经常性的小调整，防止经济的大起大落。</p>
<p>企业景气调查分析。是全国的大中型各类企业中，采取抽样调查的方法，通过问卷的形式，让企业负责人回答有关情况判断和预期。内容分为两类：一是对宏观经济总体的判断和预期；一是对企业经营状况的判断和预期，如产品订单、原材料购进、价格、存货、就业、市场需求、固定资产投资等。</p>
<h1 id="八、预测分析宏观经济决策和微观经济决策"><a href="#八、预测分析宏观经济决策和微观经济决策" class="headerlink" title="八、预测分析宏观经济决策和微观经济决策"></a>八、预测分析宏观经济决策和微观经济决策</h1><p>不仅需要了解经济运行中已经发生了的实际情况，而且更需要预见未来将发生的情况。根据已知的过去和现在推测未来，就是预测分析。</p>
<p>统计预测属于定量预测，是以数据分析为主，在预测中结合定性分析。统计预测的方法大致可分为两类：一类是主要根据指标时间数列自身变化与时间的依存关系进行预测，属于时间数列分析；另一类是根据指标之间相互影响的因果关系进行预测，属于回归分析。</p>
<p>预测分析的方法有回归分析法、滑动平均法、指数平滑法、周期（季节）变化分析和随机变化分析等。比较复杂的预测分析需要建立计量经济模型，求解模型中的参数又有许多方法。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>数据分析师</tag>
        <tag>统计</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title>免费商用字体收集</title>
    <url>/studyz.github.io/2022/07/01/2023_04_07_%E5%85%8D%E8%B4%B9%E5%95%86%E7%94%A8%E5%AD%97%E4%BD%93%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="德拉黑体"><a href="#德拉黑体" class="headerlink" title="德拉黑体"></a><a href="https://github.com/syakuzen/DelaGothic/blob/master/fonts/ttf/DelaGothicOne-Regular.ttf">德拉黑体</a></h2><blockquote>
<p>3.0&#x2F;5.0</p>
</blockquote>
<p>德拉黑体(日文名：デラゴシック，英文名：DelaGothic)德拉黑体是一款粗笔画、扁平的日系黑体字型。但是大部分文字以繁体显示，对于简体汉字的收录并不全面。</p>
<h3 id="标小智无界黑（德拉黑体补简）"><a href="#标小智无界黑（德拉黑体补简）" class="headerlink" title="标小智无界黑（德拉黑体补简）"></a>标小智无界黑（德拉黑体补简）</h3><p>标小智无界黑是基于德拉黑体进行简体字补充的字体。如果喜欢德拉黑体的，这款字体的简体中文再也不会缺字！</p>
<h2 id="阿里巴巴普惠体3-0"><a href="#阿里巴巴普惠体3-0" class="headerlink" title="阿里巴巴普惠体3.0"></a><a href="https://www.alibabafonts.com/#/home">阿里巴巴普惠体3.0</a></h2><blockquote>
<p>5.0&#x2F;5.0</p>
</blockquote>
]]></content>
      <tags>
        <tag>资源</tag>
        <tag>字体</tag>
        <tag>免费</tag>
      </tags>
  </entry>
  <entry>
    <title>ChatGPT Prompt</title>
    <url>/studyz.github.io/2023/08/12/2023_04_19_ChatGPT_Prompt/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="English-Vesion"><a href="#English-Vesion" class="headerlink" title="English Vesion"></a>English Vesion</h2><details>
  <summary>English Version</summary>
  <p> 

<ol>
<li><p>Brainstorm 10 content ideas related to [topic] that [your audience] would find interesting and beneficial.</p>
</li>
<li><p>Write a fun bedtime story for [whomever you want], with them as a main character.</p>
</li>
<li><p>Write an article about [topic]. Consider diverse perspectives and write it in a [preferred tone] tone.</p>
</li>
<li><p>Summarize [LinkedIn profile url] and list the top 5 pain points they likely face in their current role.</p>
</li>
<li><p>Create social media content for 7 days that is focused on [topic] and that will engage [target audience].</p>
</li>
</ol>
<p>  Instructions: Create social media content that is appropriate for the chosen topic and target audience. Content should be varied. Content should also include calls to action that encourage users to engage with the content, such as likes, shares, and comments.</p>
<ol start="6">
<li><p>I enjoy [list a few interests or hobbies]. What are some completely unrelated activities that I might find interesting?</p>
</li>
<li><p>Write 10 [subject lines &#x2F; headlines &#x2F; social media threads &#x2F; ad headlines &#x2F; etc.] with a curiosity gap that discuss [topic].</p>
</li>
<li><p>Pretend you are [role], come up with 10 ideas of how to do [task or problem]. Compare each of these ideas and list the pros and cons of each idea.</p>
</li>
<li><p>Summarize in table format the features, benefits, and pain solved for this product: [url to product features page].</p>
</li>
<li><p>Create a list of [10] frequently asked questions about [keyword] and provide answers for each one of them considering the SERP and rich result guidelines.</p>
</li>
<li><p>Create 5 social media posts promoting this blog post: [blog post URL].</p>
</li>
<li><p>Create a step by step guide to instruct how to [topic].</p>
  </p>
</details></li>
</ol>
<h2 id="中文版本"><a href="#中文版本" class="headerlink" title="中文版本"></a>中文版本</h2><details>
  <summary>中文版本</summary>
  <p> 
  
<ol>
<li><p>脑筋急转弯10个与[topic]相关的内容想法，让[your audience]感兴趣和受益。</p>
</li>
<li><p>为[whomever you want]编写一个fun的睡前故事，ta是故事的主要角色。</p>
</li>
<li><p>编写一个关于[topic]的的文章，考虑多种角度，使用[preferred tone]的口调。</p>
</li>
<li><p>总结[LinkedIn profile url]并 listing the top 5 pain points they likely face in their current role.</p>
</li>
<li><p>创建7天social media content，聚焦于[topic]，让[target audience]参与。</p>
</li>
</ol>
<p>  Instructions: 创建social media content，符合choosen topic and target audience。Content should be varied. Content should also include calls to action that encourage users to engage with the content, such as likes, shares, and comments.</p>
<ol start="6">
<li><p>我享受[list a few interests or hobbies]。哪些是不完全related的activity？</p>
</li>
<li><p>写10个与curiosity gap相关的[topic] theme的subject lines &#x2F; headlines &#x2F; social media threads &#x2F; ad headlines &#x2F; etc.</p>
</li>
<li><p>假设你是[role]，列出10个做[task or problem]的方法。比较每个方法并list the pros and cons of each idea.</p>
</li>
<li><p>用表格格式 summarize the features, benefits, and pain solved for this product: [url to product features page].</p>
</li>
<li><p>创建一个包含常见问题及回答的列表，关于[keyword]。</p>
</li>
<li><p>创建5个social media posts promoting this blog post: [blog post URL]。</p>
</li>
<li><p>创建一个step by step guide to instruct how to [topic]。</p>
</li>
</ol>
  </p>
</details>







]]></content>
      <tags>
        <tag>GPT</tag>
        <tag>Prompt</tag>
      </tags>
  </entry>
  <entry>
    <title>lora训练</title>
    <url>/studyz.github.io/2023/08/21/2023_04_19_lora%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://github.com/camenduru/stable-diffusion-webui-colab">https://github.com/camenduru/stable-diffusion-webui-colab</a></p>
<p><a href="https://github.com/camenduru/stable-diffusion-webui-colab/tree/drive">https://github.com/camenduru/stable-diffusion-webui-colab/tree/drive</a></p>
<p><a href="https://github.com/bmaltais/kohya_ss">kohya_ss Files:</a>  </p>
<p><a href="https://colab.research.google.com/drive/1vvi6lGdbEIbyuhM2Yg1R99dynuOkWh9Y#scrollTo=_u3q60di584x">在Google Colab上训练LORA模型,保存到谷歌云盘| 免费16GB GPU |KOHYA LORA | Dreambooth扩展 | Stable Diffusion</a></p>
<p><a href="https://github.com/Linaqruf/kohya-trainer">https://github.com/Linaqruf/kohya-trainer</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/bmaltais/kohya_ss.git</span><br><span class="line"></span><br><span class="line">cd kohya_ss</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">May need to <span class="built_in">chmod</span> +x ./setup.sh <span class="keyword">if</span> you<span class="string">&#x27;re on a machine with stricter security.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">There are additional options if needed for a runpod environment.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Call &#x27;</span>setup.sh -h<span class="string">&#x27; or &#x27;</span>setup.sh --<span class="built_in">help</span><span class="string">&#x27; for more information.</span></span></span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/antis0007/sd-webui-gelbooru-prompt">Gelbooru标签自动摘录插件 Gelbooru Prompt</a><br><a href="https://github.com/DominikDoom/a1111-sd-webui-tagcomplete/blob/main/README_ZH.md">Tag自动补全</a><br><a href="https://github.com/adieyal/sd-dynamic-prompts">Dynamic Prompts extension</a></p>
<p><a href="https://civitai.com/images/572998?period=Year&sort=Newest&view=categories">autum,sushi+goodGirl,30step</a></p>
<p><a href="https://civitai.com/images/572647?period=Year&sort=Newest&view=categories&tags=5133">https://civitai.com/images/572647?period=Year&sort=Newest&view=categories&tags=5133</a></p>
<p>![[Pasted image 20230423175817.png]]</p>
]]></content>
  </entry>
  <entry>
    <title>机器学习笔记</title>
    <url>/studyz.github.io/2023/02/19/2023_05_04_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="k-近邻算法-KNN"><a href="#k-近邻算法-KNN" class="headerlink" title="k-近邻算法(KNN)"></a><a href="https://alv1.apachecn.org/#/docs/ml/2">k-近邻算法(KNN)</a></h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>KNN是一种基本的 #分类 和 #回归 方法。给一个训练数据集，对新的输入实例，在训练数据集中找到与之最接近（直线距离，欧式距离）的K个实例，这k个实例的多数分类，就是这个输入实例的分类。</p>
<p>k值的取数决定KNN算法的准确性，太小会使模型变得复杂和过拟合，太大会使得模型变得简单。K值不宜过大过小，需要调试参数获取最好的结果。</p>
<p>为避免：</p>
<ol>
<li>避免某些特征因数值范围过大，对模型产生过大的影响。比如身高在几百英寸，体重在几十公斤，如果不归一化，模型会倾向于选择影响更大的特征。</li>
<li>避免某些特征因数值过小产生的数值精度问题。<br>需要进行 #特征归一化 处理，对特征的值进行放缩，使之落在一个特定的范围内，常见的范围是0到1之间或者-1到1之间。</li>
</ol>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>简单易实现，无需训练。</li>
<li>可以处理非线性数据。</li>
<li>对异常值不敏感。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>随着训练样本增加，计算成本会增加。</li>
<li>K值的选择会影响结果。</li>
<li>无法给出具有解释性的模型。</li>
</ol>
<h1 id="决策树-Decision-Tree"><a href="#决策树-Decision-Tree" class="headerlink" title="决策树(Decision Tree)"></a><a href="https://alv1.apachecn.org/#/docs/ml/3">决策树(Decision Tree)</a></h1><p>定义：</p>
<h1 id="降维技术"><a href="#降维技术" class="headerlink" title="降维技术"></a><a href="https://alv1.apachecn.org/#/docs/ml/13?id=%e9%99%8d%e7%bb%b4%e6%8a%80%e6%9c%af">降维技术</a></h1><p>目的：</p>
<ol>
<li>使得数据集更容易使用</li>
<li>降低很多算法的计算开销</li>
<li>去除噪音</li>
<li>使得结果易懂</li>
</ol>
<h2 id="3种降维算法"><a href="#3种降维算法" class="headerlink" title="3种降维算法"></a>3种降维算法</h2><h3 id="1-独立成分分析-Independ-Component-Analysis-ICA"><a href="#1-独立成分分析-Independ-Component-Analysis-ICA" class="headerlink" title="1. 独立成分分析(Independ Component Analysis, ICA)"></a>1. 独立成分分析(Independ Component Analysis, ICA)</h3><blockquote>
<p>通俗理解: ICA 认为观测信号是若干个独立信号的线性组合，ICA 要做的是一个解混过程。</p>
</blockquote>
<h3 id="2-因子分析-Factor-Analysis"><a href="#2-因子分析-Factor-Analysis" class="headerlink" title="2. 因子分析(Factor Analysis)"></a>2. 因子分析(Factor Analysis)</h3><blockquote>
<p>通俗理解: 将多个实测变量转换为少数几个综合指标。它反映一种降维的思想，通过降维将相关性高的变量聚在一起，从而减少需要分析的变量的数量，而减少问题分析的复杂性。</p>
</blockquote>
<h3 id="3-主成分分析-Principal-Component-Analysis-PCA"><a href="#3-主成分分析-Principal-Component-Analysis-PCA" class="headerlink" title="3. 主成分分析(Principal Component Analysis, PCA)"></a>3. 主成分分析(Principal Component Analysis, PCA)</h3><p>通俗理解：就是找出一个最主要的特征，然后进行分析。</p>
<blockquote>
<p>PCA 工作原理</p>
</blockquote>
<ol>
<li>找出第一个主成分的方向，也就是数据 <code>方差最大</code> 的方向。</li>
<li>找出第二个主成分的方向，也就是数据 <code>方差次大</code> 的方向，并且该方向与第一个主成分方向 <code>正交(orthogonal 如果是二维空间就叫垂直)</code>。</li>
<li>通过这种方式计算出所有的主成分方向。</li>
<li>通过数据集的协方差矩阵及其特征值分析，我们就可以得到这些主成分的值。</li>
<li>一旦得到了协方差矩阵的特征值和特征向量，我们就可以保留最大的 N 个特征。这些特征向量也给出了 N 个最重要特征的真实结构，我们就可以通过将数据乘上这 N 个特征向量 从而将它转换到新的空间上。</li>
</ol>
<p>为什么正交？</p>
<ol>
<li>正交是为了数据有效性损失最小</li>
<li>正交的一个原因是特征值的特征向量是正交的</li>
</ol>
<blockquote>
<p>PCA 优缺点</p>
</blockquote>
<p>优点：降低数据的复杂性，识别最重要的多个特征。<br>缺点：不一定需要，且可能损失有用信息。<br>适用数据类型：数值型数据。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数据填补算法的选择主要依据</title>
    <url>/studyz.github.io/2022/04/19/2023_05_05_%E6%95%B0%E6%8D%AE%E5%A1%AB%E8%A1%A5%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%89%E6%8B%A9%E4%B8%BB%E8%A6%81%E4%BE%9D%E6%8D%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据填补算法的选择主要依据以下几个因素:</p>
<ol>
<li>数据类型:数值型数据可以选择均值&#x2F;中位数填补,分类数据可以选择最频繁值填补。时间序列数据可以考虑插值法或回归预测填补。</li>
<li>缺失值占比:缺失值比例越大,删除行&#x2F;特征效果越差,需要更复杂的填补方法。缺失值比例小,简单填补法效果也不错。</li>
<li>数据分布:数据分布越复杂,简单填补法效果越差,需要根据数据分布选择合适的填补方法。</li>
<li>特征相关性:特征之间相关性越强,可以考虑矩阵填补,用其他特征预测当前特征缺失值。相关性弱需要独立填补。</li>
<li>填补对模型的影响:填补值的准确性会直接影响后续机器学习模型的效果,需要评估不同填补方法对模型效果的影响。<br>所以,在选择数据填补算法时,主要依据数据类型、缺失值占比、数据分布以及特征相关性进行初选,然后可以尝试不同算法,评估填补后的数据对机器学习模型效果的影响,选择一个综合效果最好的算法。</li>
</ol>
<p>常见的选择思路如:</p>
<ol>
<li>分类&#x2F;数值数据 &amp; 缺失值比例小:均值&#x2F;中位数&#x2F;最频繁值填补</li>
<li>数值数据 &amp; 数据分布复杂:KNN填补</li>
<li>特征相关性强:矩阵填补</li>
<li>时间序列数据:插值法或回归预测填补</li>
<li>缺失值比例大:需要尝试多种复杂方法,评估效果选择最佳方案<br>所以综上,数据填补算法的选择需要根据具体的数据集与情况综合判断,没有一个通用的选择顺序,需要尝试与评估不同方法的效果。</li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>数据分析师</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>5W2H模型在数据分析中的应用</title>
    <url>/studyz.github.io/2023/06/03/2023_06_03_5W2H%E6%A8%A1%E5%9E%8B%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="5W2H模型在数据分析中的应用"><a href="#5W2H模型在数据分析中的应用" class="headerlink" title="5W2H模型在数据分析中的应用"></a>5W2H模型在数据分析中的应用</h1><p>5W2H模型可以很好地应用于数据分析，主要做以下几点：</p>
<ol>
<li><p>梳理问题：使用5W2H各个维度的问题，对进行数据分析的问题或需求进行清晰地说明。</p>
<ul>
<li>What：问题是什么？需要分析什么领域的数据？</li>
<li>Who：涉及哪些对象、群体？目标用户分析是谁？</li>
<li>When：哪个时间段的数据需要分析？</li>
<li>Where：哪个地区的数据？</li>
<li>Why：需要分析数据的目的是什么？解决什么问题？</li>
<li>How：数据分析方法是怎样的？</li>
<li>How much：分析结果的指标是多少？</li>
</ul>
</li>
<li><p>搜集数据：根据5W2H分析需求，集中相关的数据。</p>
<ul>
<li>明确Who、What、When、Where后，能确定需要哪些数据表，搜集哪些记录。</li>
</ul>
</li>
<li><p>处理数据：对搜集到的数据进行清洗、转换和整合，制作可视化。</p>
</li>
<li><p>分析结果：使用How指导数据分析方法，How much指出结果衡量标准。</p>
</li>
<li><p>建议改进：根据分析结果给出改进建议，回答Why问题。</p>
</li>
</ol>
<p>综上，使用5W2H来梳理数据分析问题和需求，能明确分析的方向性和重点，有利于制定目标和选择数据驱动的方法与策略，更快获得可信赖的结果与洞察力。</p>
<p>5W2H也可以作为数据分析报告的框架，分别回答7个方面问题，全面呈现分析结果和建议。</p>
<p>在数字化时代，5W2H这一古老而简单的分析模型仍被广泛使用，它为各种复杂问题提供了一种思考方式，有助于系统、全面地完成数据分析任务。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>方法论</tag>
      </tags>
  </entry>
  <entry>
    <title>7大经典回归模型</title>
    <url>/studyz.github.io/2023/08/01/2023_08_01_7%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是回归分析？"><a href="#什么是回归分析？" class="headerlink" title="什么是回归分析？"></a>什么是回归分析？</h1><p>回归分析是一种预测性的建模技术，它研究的是因变量（目标）和自变量（预测器）之间的关系。这种技术通常用于预测分析，时间序列模型以及发现变量之间的因果关系。例如，司机的鲁莽驾驶与道路交通事故数量之间的关系，最好的研究方法就是回归。</p>
<p>回归分析是建模和分析数据的重要工具。在这里，我们使用曲线&#x2F;线来拟合这些数据点，在这种方式下，从曲线或线到数据点的距离差异最小。我会在接下来的部分详细解释这一点。</p>
<p><img src="/studyz.github.io/2023/08/01/2023_08_01_7%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/10001.png"></p>
<h1 id="我们为什么使用回归分析？"><a href="#我们为什么使用回归分析？" class="headerlink" title="我们为什么使用回归分析？"></a>我们为什么使用回归分析？</h1><p>如上所述，回归分析估计了两个或多个变量之间的关系。下面，让我们举一个简单的例子来理解它：</p>
<p>比如说，在当前的经济条件下，你要估计一家公司的销售额增长情况。现在，你有公司最新的数据，这些数据显示出销售额增长大约是经济增长的2.5倍。那么使用回归分析，我们就可以根据当前和过去的信息来预测未来公司的销售情况。</p>
<p>使用回归分析的好处良多。具体如下：</p>
<ol>
<li>它表明自变量和因变量之间的显著关系；</li>
<li>它表明多个自变量对一个因变量的影响强度。</li>
</ol>
<p>回归分析也允许我们去比较那些衡量不同尺度的变量之间的相互影响，如价格变动与促销活动数量之间联系。这些有利于帮助市场研究人员，数据分析人员以及数据科学家排除并估计出一组最佳的变量，用来构建预测模型。</p>
<h1 id="我们有多少种回归技术？"><a href="#我们有多少种回归技术？" class="headerlink" title="我们有多少种回归技术？"></a>我们有多少种回归技术？</h1><p>有各种各样的回归技术用于预测。这些技术主要有三个度量（自变量的个数，因变量的类型以及回归线的形状）。我们将在下面的部分详细讨论它们。</p>
<p><img src="/studyz.github.io/2023/08/01/2023_08_01_7%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/10002.jpg"></p>
<p>对于那些有创意的人，如果你觉得有必要使用上面这些参数的一个组合，你甚至可以创造出一个没有被使用过的回归模型。但在你开始之前，先了解如下最常用的回归方法：</p>
<h3 id="1-Linear-Regression线性回归"><a href="#1-Linear-Regression线性回归" class="headerlink" title="1-Linear-Regression线性回归"></a>1-Linear-Regression线性回归</h3><p>它是最为人熟知的建模技术之一。线性回归通常是人们在学习预测模型时首选的技术之一。在这种技术中，因变量是连续的，自变量可以是连续的也可以是离散的，回归线的性质是线性的。</p>
<p>线性回归使用最佳的拟合直线（也就是回归线）在因变量（Y）和一个或多个自变量（X）之间建立一种关系。</p>
<p>用一个方程式来表示它，即Y&#x3D;a+b*X+e，其中a表示截距，b表示直线的斜率，e是误差项。这个方程可以根据给定的预测变量（s）来预测目标变量的值。<br><img src="/studyz.github.io/2023/08/01/2023_08_01_7%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/10003.png"></p>
<p>一元线性回归和多元线性回归的区别在于，多元线性回归有（&gt;1）个自变量，而一元线性回归通常只有1个自变量。现在的问题是“我们如何得到一个最佳的拟合线呢？”。</p>
<p><strong>如何获得最佳拟合线（a和b的值）？</strong></p>
<p>这个问题可以使用最小二乘法轻松地完成。最小二乘法也是用于拟合回归线最常用的方法。对于观测数据，它通过最小化每个数据点到线的垂直偏差平方和来计算最佳拟合线。因为在相加时，偏差先平方，所以正值和负值没有抵消。</p>
<p><img src="/studyz.github.io/2023/08/01/2023_08_01_7%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/10004.jpg"></p>
<p>我们可以使用R-square指标来评估模型性能。想了解这些指标的详细信息，可以阅读：模型性能指标Part 1,Part 2.</p>
<blockquote>
<p><strong>要点：</strong></p>
<p>1.自变量与因变量之间必须有线性关系</p>
<p>2.多元回归存在多重共线性，自相关性和异方差性。</p>
<p>3.线性回归对异常值非常敏感。它会严重影响回归线，最终影响预测值。</p>
<p>4.多重共线性会增加系数估计值的方差，使得在模型轻微变化下，估计非常敏感。结果就是系数估计值不稳定</p>
<p>5.在多个自变量的情况下，我们可以使用向前选择法，向后剔除法和逐步筛选法来选择最重要的自变量。</p>
</blockquote>
<h3 id="2-Logistic-Regression逻辑回归"><a href="#2-Logistic-Regression逻辑回归" class="headerlink" title="2-Logistic-Regression逻辑回归"></a>2-Logistic-Regression逻辑回归</h3><p>逻辑回归是用来计算“事件&#x3D;Success”和“事件&#x3D;Failure”的概率。当因变量的类型属于二元（1 &#x2F; 0，真&#x2F;假，是&#x2F;否）变量时，我们就应该使用逻辑回归。这里，Y的值从0到1，它可以用下方程表示。</p>
<p>odds&#x3D; p&#x2F; (1-p) &#x3D; probability of event occurrence &#x2F; probability of not event occurrenceln(odds) &#x3D; ln(p&#x2F;(1-p))logit(p) &#x3D; ln(p&#x2F;(1-p)) &#x3D; b0+b1X1+b2X2+b3X3….+bkXk</p>
<p>上述式子中，p表述具有某个特征的概率。你应该会问这样一个问题：“我们为什么要在公式中使用对数log呢？”。</p>
<p>因为在这里我们使用的是的二项分布（因变量），我们需要选择一个对于这个分布最佳的连结函数。它就是Logit函数。在上述方程中，通过观测样本的极大似然估计值来选择参数，而不是最小化平方和误差（如在普通回归使用的）。</p>
<p><img src="/studyz.github.io/2023/08/01/2023_08_01_7%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/10005.jpg"></p>
<blockquote>
<p><strong>要点：</strong></p>
<p>1.它广泛的用于分类问题。</p>
<p>2.逻辑回归不要求自变量和因变量是线性关系。它可以处理各种类型的关系，因为它对预测的相对风险指数OR使用了一个非线性的log转换。</p>
<p>3.为了避免过拟合和欠拟合，我们应该包括所有重要的变量。有一个很好的方法来确保这种情况，就是使用逐步筛选方法来估计逻辑回归。</p>
<p>4.它需要大的样本量，因为在样本数量较少的情况下，极大似然估计的效果比普通的最小二乘法差。</p>
<p>5.自变量不应该相互关联的，即不具有多重共线性。然而，在分析和建模中，我们可以选择包含分类变量相互作用的影响。</p>
<p>6.如果因变量的值是定序变量，则称它为序逻辑回归。</p>
<p>7.如果因变量是多类的话，则称它为多元逻辑回归。</p>
</blockquote>
<h3 id="3-Polynomial-Regression多项式回归"><a href="#3-Polynomial-Regression多项式回归" class="headerlink" title="3-Polynomial-Regression多项式回归"></a>3-Polynomial-Regression多项式回归</h3><p>对于一个回归方程，如果自变量的指数大于1，那么它就是多项式回归方程。如下方程所示：y&#x3D;a+b*x^2</p>
<p>在这种回归技术中，最佳拟合线不是直线。而是一个用于拟合数据点的曲线。<br><img src="/studyz.github.io/2023/08/01/2023_08_01_7%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/10006.png"></p>
<blockquote>
<p>重点：</p>
<p>虽然会有一个诱导可以拟合一个高次多项式并得到较低的错误，但这可能会导致过拟合。你需要经常画出关系图来查看拟合情况，并且专注于保证拟合合理，既没有过拟合又没有欠拟合。</p>
</blockquote>
<p>下面是一个图例，可以帮助理解：</p>
<p><img src="/studyz.github.io/2023/08/01/2023_08_01_7%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/10007.png"></p>
<p>明显地向两端寻找曲线点，看看这些形状和趋势是否有意义。更高次的多项式最后可能产生怪异的推断结果。</p>
<h3 id="4-Stepwise-Regression逐步回归"><a href="#4-Stepwise-Regression逐步回归" class="headerlink" title="4-Stepwise-Regression逐步回归"></a>4-Stepwise-Regression逐步回归</h3><p>在处理多个自变量时，我们可以使用这种形式的回归。在这种技术中，自变量的选择是在一个自动的过程中完成的，其中包括非人为操作。</p>
<p>这一壮举是通过观察统计的值，如R-square，t-stats和AIC指标，来识别重要的变量。逐步回归通过同时添加&#x2F;删除基于指定标准的协变量来拟合模型。</p>
<p>下面列出了一些最常用的逐步回归方法：</p>
<ul>
<li>标准逐步回归法做两件事情。即增加和删除每个步骤所需的预测。</li>
<li>向前选择法从模型中最显著的预测开始，然后为每一步添加变量。</li>
<li>向后剔除法与模型的所有预测同时开始，然后在每一步消除最小显着性的变量。</li>
</ul>
<p>这种建模技术的目的是使用最少的预测变量数来最大化预测能力。这也是处理高维数据集的方法之一。</p>
<h3 id="5-Ridge-Regression岭回归"><a href="#5-Ridge-Regression岭回归" class="headerlink" title="5-Ridge-Regression岭回归"></a>5-Ridge-Regression岭回归</h3><p>岭回归分析是一种用于存在多重共线性（自变量高度相关）数据的技术。在多重共线性情况下，尽管最小二乘法（OLS）对每个变量很公平，但它们的差异很大，使得观测值偏移并远离真实值。岭回归通过给回归估计上增加一个偏差度，来降低标准误差。</p>
<p>上面，我们看到了线性回归方程。还记得吗？它可以表示为：</p>
<p>y&#x3D;a+b*x这个方程也有一个误差项。完整的方程是：</p>
<p>y&#x3D;a+b*x+e (error term),  [error term is the value needed to correct for a prediction error between the observed and predicted value]</p>
<p>=&gt; y&#x3D;a+y&#x3D; a+ b1x1+ b2x2+….+e, for multiple independent variables.</p>
<p>在一个线性方程中，预测误差可以分解为2个子分量。一个是偏差，一个是方差。预测错误可能会由这两个分量或者这两个中的任何一个造成。在这里，我们将讨论由方差所造成的有关误差。</p>
<p>岭回归通过收缩参数λ（lambda）解决多重共线性问题。看下面的公式</p>
<p><img src="/studyz.github.io/2023/08/01/2023_08_01_7%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/5.jpg" alt="Image"></p>
<p>在这个公式中，有两个组成部分。第一个是最小二乘项，另一个是β2（β-平方）的λ倍，其中β是相关系数。为了收缩参数把它添加到最小二乘项中以得到一个非常低的方差。</p>
<blockquote>
<p>要点：</p>
<p>1.除常数项以外，这种回归的假设与最小二乘回归类似；</p>
<p>2.它收缩了相关系数的值，但没有达到零，这表明它没有特征选择功能</p>
<p>3.这是一个正则化方法，并且使用的是L2正则化。</p>
</blockquote>
<h3 id="6-Lasso-Regression套索回归"><a href="#6-Lasso-Regression套索回归" class="headerlink" title="6-Lasso-Regression套索回归"></a>6-Lasso-Regression套索回归</h3><p>它类似于岭回归，Lasso （Least Absolute Shrinkage and Selection Operator）也会惩罚回归系数的绝对值大小。此外，它能够减少变化程度并提高线性回归模型的精度。看看下面的公式：</p>
<p><img src="/studyz.github.io/2023/08/01/2023_08_01_7%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/6.jpg" alt="Image"></p>
<p>Lasso 回归与Ridge回归有一点不同，它使用的惩罚函数是绝对值，而不是平方。这导致惩罚（或等于约束估计的绝对值之和）值使一些参数估计结果等于零。使用惩罚值越大，进一步估计会使得缩小值趋近于零。这将导致我们要从给定的n个变量中选择变量。</p>
<blockquote>
<p>要点：</p>
<p>1.除常数项以外，这种回归的假设与最小二乘回归类似；</p>
<p>2.它收缩系数接近零（等于零），这确实有助于特征选择；</p>
<p>3.这是一个正则化方法，使用的是L1正则化；</p>
<p>如果预测的一组变量是高度相关的，Lasso 会选出其中一个变量并且将其它的收缩为零。</p>
</blockquote>
<h3 id="7-ElasticNet回归"><a href="#7-ElasticNet回归" class="headerlink" title="7-ElasticNet回归"></a>7-ElasticNet回归</h3><p>ElasticNet是Lasso和Ridge回归技术的混合体。它使用L1来训练并且L2优先作为正则化矩阵。当有多个相关的特征时，ElasticNet是很有用的。Lasso 会随机挑选他们其中的一个，而ElasticNet则会选择两个。<br><img src="/studyz.github.io/2023/08/01/2023_08_01_7%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/7.jpg" alt="Image"></p>
<p>Lasso和Ridge之间的实际的优点是，它允许ElasticNet继承循环状态下Ridge的一些稳定性。</p>
<blockquote>
<p><strong>要点：</strong></p>
<p>1.在高度相关变量的情况下，它会产生群体效应；</p>
<p>2.选择变量的数目没有限制；</p>
<p>3.它可以承受双重收缩。</p>
</blockquote>
<p>除了这7个最常用的回归技术，你也可以看看其他模型，如Bayesian、Ecological和Robust回归。</p>
<h1 id="如何正确选择回归模型？"><a href="#如何正确选择回归模型？" class="headerlink" title="如何正确选择回归模型？"></a>如何正确选择回归模型？</h1><p>当你只知道一个或两个技术时，生活往往很简单。我知道的一个培训机构告诉他们的学生，如果结果是连续的，就使用线性回归。如果是二元的，就使用逻辑回归！然而，在我们的处理中，可选择的越多，选择正确的一个就越难。类似的情况下也发生在回归模型中。</p>
<p>在多类回归模型中，基于自变量和因变量的类型，数据的维数以及数据的其它基本特征的情况下，选择最合适的技术非常重要。以下是你要选择正确的回归模型的<strong>关键因素</strong>：</p>
<p>1.数据探索是构建预测模型的必然组成部分。在选择合适的模型时，比如识别变量的关系和影响时，它应该首选的一步。</p>
<p>2. 比较适合于不同模型的优点，我们可以分析不同的指标参数，如统计意义的参数，R-square，Adjusted R-square，AIC，BIC以及误差项，另一个是Mallows’ Cp准则。这个主要是通过将模型与所有可能的子模型进行对比（或谨慎选择他们），检查在你的模型中可能出现的偏差。</p>
<p>3.交叉验证是评估预测模型最好额方法。在这里，将你的数据集分成两份（一份做训练和一份做验证）。使用观测值和预测值之间的一个简单均方差来衡量你的预测精度。</p>
<p>4.如果你的数据集是多个混合变量，那么你就不应该选择自动模型选择方法，因为你应该不想在同一时间把所有变量放在同一个模型中。</p>
<p>5.它也将取决于你的目的。可能会出现这样的情况，一个不太强大的模型与具有高度统计学意义的模型相比，更易于实现。</p>
<p>6.回归正则化方法（Lasso，Ridge和ElasticNet）在高维和数据集变量之间多重共线性情况下运行良好。</p>
<p>作者：Sunil Ray<br>ref: <a href="https://mp.weixin.qq.com/s?__biz=MjM5NzEyMzg4MA==&mid=2649468348&idx=6&sn=98e8ec166f38992470bd2de5979c33f0&chksm=bec1cffb89b646ed54437df231cfe3c3cf1a66010672daa570a5791d29ee0c022cf7fd36556b&scene=27">7大经典回归模型</a></p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>模型</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>回归模型</tag>
        <tag>机器算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Apple TV 4K 三代</title>
    <url>/studyz.github.io/2023/08/10/2023_08_10_AppleTV4K/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>以前发布节奏都是3年左右更新一代，现在直接一年一更了吗难道？<br>上一代还是2021年发布的。<br>来跟大家分享下新款的Apple TV 4K都更新了哪些东西？值得买吗？已经买了2021款的需要换吗？</p>
</blockquote>
<h1 id="两个版本"><a href="#两个版本" class="headerlink" title="两个版本"></a>两个版本</h1><p><img src="https://pic1.zhimg.com/v2-227b2d5b18b852460deaf6c04118bf9c_r.jpg"></p>
<p><strong>无线版：</strong> 只能WiFi连接，存储64GB<br><strong>有线版本：</strong> 支持WiFi和以太网连接，存储128GB</p>
<h1 id="与前代对比："><a href="#与前代对比：" class="headerlink" title="与前代对比："></a>与前代对比：</h1><ul>
<li>A15芯片</li>
<li>支持 HDR 10+</li>
<li>遥控器充电口更换为 USB-C</li>
<li>内存从3GB升级到4GB</li>
<li>设备容量翻倍，无 32 GB 机型。现在为 64 GB 和 128 GB<br><img src="https://pic1.zhimg.com/v2-4b8debba68fc6523885458324be7d6b9_r.jpg?source=1940ef5c" alt="对比"></li>
</ul>
<h3 id="升级点-1：芯片从A12提升到了A15"><a href="#升级点-1：芯片从A12提升到了A15" class="headerlink" title="升级点-1：芯片从A12提升到了A15"></a>升级点-1：芯片从A12提升到了A15</h3><p><img src="https://pic3.zhimg.com/v2-cee98cb8cd1005ce49538f8d071cceba_b.jpg"></p>
<p>新发布的iPad 2022款3599元起，使用的只是A14芯片！<br>A15对比A12的性能对比数据，CPU提升40%、GPU提升80%</p>
<p><img src="https://pic1.zhimg.com/80/v2-6e3e66793387915d4a72e3cee3a93b78_1440w.webp"></p>
<p>晶体管数量A15比A12翻了一倍不止！</p>
<p><img src="https://pic2.zhimg.com/v2-a6c0c9fe1cafc6ffb132a50c57b13de5_r.jpg"></p>
<p>安兔兔跑分来看，A15比A12跑分高了51%</p>
<p>不过苹果官方给的新款Apple TV 数据：</p>
<p>CPU 性能现在比上一代快 50%，提供更出色的响应能力、更快的导航和更快速的 UI 动画。GPU 性能现在比上一代产品快 30%，游戏体验更加流畅。</p>
<p>可能是没有风扇的缘故，性能有所保留。</p>
<p>一个电视盒子，价格1000块，直接上了A15，苹果想干啥？</p>
<p>这个盒子完全可以用来玩原神了，而且存储最高到了128GB</p>
<p><strong>苹果肯定是想发展电视游戏平台了！</strong> 已有的Acade会员加上现在的硬件大幅度升级，以后在Apple TV玩原神不是梦，甚至更大胆一点，会不会和明年苹果要发布的AR&#x2F;MR有联动？</p>
<h3 id="升级点2：变得更薄更小了，重量减轻了"><a href="#升级点2：变得更薄更小了，重量减轻了" class="headerlink" title="升级点2：变得更薄更小了，重量减轻了"></a>升级点2：变得更薄更小了，重量减轻了</h3><p>由于采用A15芯片无风扇设计，与上一代Apple TV 4K相比，该设备的厚度减少了10%以上，重量减轻了约50%。</p>
<p><img src="https://pic4.zhimg.com/v2-bc4357f9adfd09eca56754d61191da13_r.jpg"></p>
<h3 id="升级点3：支持HDR10"><a href="#升级点3：支持HDR10" class="headerlink" title="升级点3：支持HDR10+"></a>升级点3：支持HDR10+</h3><p><img src="https://pic3.zhimg.com/v2-3de5f42b7fe35f25601971c743cce8fe_r.jpg"></p>
<p>对HDR的支持算是补齐了</p>
<h3 id="升级点4：遥控器充电口更换为-USB-C"><a href="#升级点4：遥控器充电口更换为-USB-C" class="headerlink" title="升级点4：遥控器充电口更换为-USB-C"></a>升级点4：遥控器充电口更换为-USB-C</h3><p><img src="https://pic2.zhimg.com/v2-1a672d02a9a4e251f5ff370efcc5fe41_r.jpg"></p>
<p>Apple TV的遥控器不怎么需要充电，我的日常半年都不充电一次，</p>
<p>不过连遥控器都上USB-C了，看来明年iPhone肯定也会全系上USB-C了～</p>
<h1 id="遗憾："><a href="#遗憾：" class="headerlink" title="遗憾："></a>遗憾：</h1><ol>
<li>HDMI 2.1 目前仍然只能支持4K 60帧（怀疑使用的是满血版HDMI 2.1，但是固件做了限制）</li>
<li>音频Dolby Atoms True HD解码，但是不支持源码输出（给新款HomePods准备的？）</li>
<li>不支持AV1和H.266&lt;VVC&gt;编码</li>
</ol>
<p>不过以上其实对绝大部分人没啥影响，放心冲就行了，1000块的价格完全是买A15芯片送盒子了。</p>
<h1 id="选购建议"><a href="#选购建议" class="headerlink" title="选购建议"></a>选购建议</h1><p>还没买的直接上128GB有线版本<br>如果你现在已经买了Apple TV 4K 2021款，那么可以等等，毕竟A12已经性能过剩了，可以等苹果后续系统更新会不会有更大的动作，再考虑是否换新。</p>
<h1 id="买港版还是美版"><a href="#买港版还是美版" class="headerlink" title="买港版还是美版"></a>买港版还是美版</h1><p>建议美版，港版和美版的唯一差别就是电源线插头的区别，美版电源插头可以直接用，港版电源插头需要买转接头（插座会高出一大坨的东西），或者买个国标的8字电源线，替换一下。<br><img src="https://pic2.zhimg.com/v2-b184e255c818a5aaabb3410eaf7e5eb1_b.jpg"></p>
<h1 id="Apple-TV-录屏："><a href="#Apple-TV-录屏：" class="headerlink" title="Apple-TV-录屏："></a>Apple-TV-录屏：</h1><p><strong>系统版本：</strong> tvOS 16.3.3<br><strong>需要硬件设备：</strong> 一台Apple TV，一台macOS设备；<br><strong>网络要求：</strong> 保证Apple TV和你的macOS设备在同一局域网内；<br><strong>软件：</strong> macOS系统的<strong>QuickTime Player</strong><br><strong>操作路径：</strong> 打开<strong>QuickTime Player</strong> -&gt; 菜单栏 -&gt; 文件 -&gt; 新建影片录制 -&gt; 点击红色圆形「录制」按钮右侧的箭头 -&gt; 选择Apple TV设备，例如我家是「家庭影院」  </p>
<h3 id="Apple-TV-录屏需注意的坑"><a href="#Apple-TV-录屏需注意的坑" class="headerlink" title="Apple-TV-录屏需注意的坑"></a>Apple-TV-录屏需注意的坑</h3><p>如果你的QuickTime Player没有出现Apple TV（一般TVOS 16更新后会出现这种）</p>
<ol>
<li><p>设置 -&gt; 「隔空播放和HomeKit」 -&gt; 「会议室显示器」 -&gt; 改为打开<br>如果这个时候，你在QuickTime Player还是没有看到Apple TV，那么你应该是有HomePod，并把<br>HomePod设置成了<strong>默认音频输出</strong>了。</p>
</li>
<li><p>设置 -&gt; 「视频和音频」 -&gt; 「音频」 -&gt; 选择电视扬声器<br>这时候就能在QuickTime Player找到Apple TV了！</p>
</li>
</ol>
<h1 id="如何显示视频码率等信息？"><a href="#如何显示视频码率等信息？" class="headerlink" title="如何显示视频码率等信息？"></a>如何显示视频码率等信息？</h1><p><a href="https://zhuanlan.zhihu.com/p/553483619">https://zhuanlan.zhihu.com/p/553483619</a></p>
]]></content>
      <categories>
        <category>日常分享</category>
        <category>数码</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数码</tag>
        <tag>Apple</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析师所需的技术与理论</title>
    <url>/studyz.github.io/2023/10/23/2023_09_10_%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%88%E6%89%80%E9%9C%80%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%8E%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>对数据分析师来说，要想避免沦为取数、跑数的工具人命运，就明确并巩固自己的优势与价值。因此明确数据分析师的成长路径、能力要求、能力提升方法就显得格外重要。而笔者作为数据分析专家，也就此分享了自己的思考与见解。</p>
</blockquote>
<h1 id="一、数据分析师的种类、职责与升级路线"><a href="#一、数据分析师的种类、职责与升级路线" class="headerlink" title="一、数据分析师的种类、职责与升级路线"></a>一、数据分析师的种类、职责与升级路线</h1><p>在国内数据分析师一般分为5大种类：<strong>数据产品、数据分析师、数据建模师、数据工程师与数据科</strong>学家，这5类人才的必备能力和成长路线我们来逐一介绍。</p>
<h3 id="1-1数据产品"><a href="#1-1数据产品" class="headerlink" title="1.1数据产品"></a>1.1数据产品</h3><p><img src="https://image.woshipm.com/wp-files/2020/02/VelM8G0ntrFFUADracIt.png"></p>
<p>数据产品概览图</p>
<p>在产品的基础上，增加数据思维。</p>
<p>数据产品不仅懂得埋点原理，能够通过抓包等工具抓取数据并进行分析。同时还能够参与数据化产品的制作，如BI报表、CRM系统、AB test试验后台等。</p>
<p>老板会说：“去给我做个神策、GrowingIO那样婶儿的平台出来”，然后你就根据老板的需求，转化为详细的技术需求，提给技术去开发，这就是数据产品的日常。</p>
<p><strong>1.1.1 成长路线：</strong> CGO、增长专家、产品总监、数据产品总监、数据运营总监</p>
<p><strong>1.1.2 必备能力</strong></p>
<ul>
<li>① 数据技术</li>
<li>② 可视化</li>
<li>⑤ 业务思维</li>
<li>⑦ 专业能力</li>
<li>⑧ 沟通能力</li>
</ul>
<p>（①②⑤⑦⑧是啥？下文详解）</p>
<p><strong>1.1.3 成长建议</strong></p>
<ol>
<li>数据产品一般会对编程、数据处理、统计等专业知识方面较弱，建议加强数据分析能力，做个有技术、分析能力的产品。</li>
<li>既然有产品属性，那就涉及到与技术无止境的扯皮之中，如何提升自己业务与沟通能力让自己更专业，同时使工作流程更加顺畅，这便是数据产品的王者能力。</li>
</ol>
<h3 id="1-2-数据分析师"><a href="#1-2-数据分析师" class="headerlink" title="1.2 数据分析师"></a>1.2 数据分析师</h3><p><img src="https://image.woshipm.com/wp-files/2020/02/XmNDqkOc1XOsSXIZ7Lw8.png"></p>
<p>数据分析师概览图</p>
<p>这就是我们常说的商业化数据分析师，主要负责01搭建可视化监控报表，利用数据挖掘和洞察业务，为需求部门提供数据支撑、分析报告、商业化模型等服务，这里面的key word是监控、挖掘、有价值和服务，在公司里担任领导的眼睛与大脑的角色。</p>
<p><strong>1.2.1 成长路线：</strong> CGO、增长专家、数据咨询专家、数据分析总监、数据运营总监</p>
<p><strong>1.2.2 必备能力</strong></p>
<ul>
<li>① 数据技术</li>
<li>② 可视化</li>
<li>③ 统计学基础</li>
<li>⑤ 业务思维能力</li>
<li>⑦ 专业能力</li>
<li><strong>⑧ 沟通能力</strong></li>
</ul>
<p>（①③③⑤⑦⑧是啥？下文详解）</p>
<p><strong>1.2.3 成长建议</strong></p>
<p><strong>（1）一定要重视可视化</strong></p>
<p>为什么呢？</p>
<p>因为数据分析师花90%的时间用在处理数据上，只贡献了10%的价值，而老板看到你的报告，却用了不到10%的时间便做出决策，贡献了90%的价值，所以说BI可视化尤为重要。下图给大家展示可视化的正反两个例子A和B：</p>
<p><img src="https://image.woshipm.com/wp-files/2020/02/dOg1xfwIxgwmLXCmO3zg.png"></p>
<p>可视化对比图</p>
<p>同样是数据分析师做出来的AB两张图，看了图A的老板点头肯定，看了图B的老板肯定想弄死你，正愁没人裁，有没有？</p>
<p><strong>（2）分析师要有自己的业务思维能力</strong></p>
<p>什么意思？比如老板经常会问你今天的DAU怎么暴涨了，留存怎么掉了等等。</p>
<p>许多大神都有自己的独立业务思维，对答如流，迅速解决问题，并有自己的一套思维，什么留存“六脉神剑”啊，增长“九宫格”啊啥的，这都是业务思维沉淀形成的。</p>
<p><strong>（3）千万不要把数据分析师做成取数的、跑数的，那样你的可替代性太强</strong></p>
<p>如果明天要裁一个数据分析师，那么这类“工具人”就是首选。数据分析师的价值是挖掘数据中的价值并让领导知道你这么做的价值，不要你觉得，要你的领导和你都觉得，这才是最重要的。</p>
<p><strong>（4）沟通能力</strong></p>
<p>这个是我面试经常会问的问题，你觉得数据分析师最重要的能力是什么？</p>
<p>对，就是沟通能力，如果你连需求方想要的是什么都唠不明白，那你如何服务于他，目标错误高效的执行就是灾难，咔咔做了2周，发现不是人家想要的，这种事在工作上并不少见，所以说沟通真的很重要。</p>
<p><strong>（5）要养成大局观</strong></p>
<p>作为数据分析师不能总局限于自己业务的那些数，也要抬头看看市场上大盘变化，以及竞品变化。</p>
<p>分析格局的大小源自看待问题的高度，这一点非常重要，初期可以慢慢养成，这也是高阶分析师必备的能力。</p>
<h3 id="1-3-数据建模师"><a href="#1-3-数据建模师" class="headerlink" title="1.3 数据建模师"></a>1.3 数据建模师</h3><p><img src="https://image.woshipm.com/wp-files/2020/02/mncK7vwEjImFci4UYNqM.png"></p>
<p>数据建模师概览图</p>
<p>数据建模师也叫算法工程师，是数理统计知识、编程与业务思维集一身的模型大师，通过建立数学模型、利用算法实现增长，可以说是一家产品的灵魂工作者，你就说信息流产品的推荐算法核不核心、金融行业的反欺诈和信用评级厉不厉害，P2P的智能配标优不优秀。</p>
<p><strong>1.3.1 成长路线：</strong> CTO、技术总监、资深算法工程师</p>
<p><strong>1.3.2 必备能力</strong></p>
<ul>
<li>① 数据技术</li>
<li>③ 统计学基础</li>
<li>④ 建模能力</li>
<li>⑤ 业务思维能力</li>
<li>⑥ 大局能力</li>
<li>⑦ 专业能力</li>
</ul>
<p>（①③④⑤⑥⑦是啥？下文详解）</p>
<p><strong>1.3.3 成长建议</strong></p>
<p><strong>（1）技术不用说，那必须杠杠的，但容易钻入数据的黑洞，沉迷于算法但又无法与实际业务相结合，最终项目流产</strong></p>
<p>谷歌眼镜厉不厉害，炫不炫酷，最终惨遭压箱底，暂停个人消费者服务的命运，为什么？</p>
<p>出发点很好，但花费过高、周边技术不完善等因素，使其不具备商业价值，最终倒在了5G之前。</p>
<p>我还认识一个彩票公司的小哥，自称研制出了一套“迷人”的算法，能够让公司收益最大化，可最终…呵呵。</p>
<p>我想说的是技术一定要结合实际业务，通过技术变现这才是王道，并不是所有公司都有钱有精力去做“华而不实”的事情，尤其是在目前的大环境下。</p>
<p><strong>（2）大家都认为技术不需要沟通，我们的通用语言是R、python、java、自然语言，很冰冷很cool</strong></p>
<p>但熟不知你若会技术又有业务头脑，那总监的位置是不是在向你招手；你若懂业务、懂管理又会为人处世，拿下CTO这个位置是不是志在必得。</p>
<p>当然也有喜欢钻研算法，不掺乎管理层的资深技术，所谓事了拂衣去，深藏功与名，说的就是这些人。</p>
<p>不管怎么说，之所以能够有今天的成就，除了过硬的技术外，很好的沟通能力也是必不可少的。</p>
<h3 id="1-4-数据工程师"><a href="#1-4-数据工程师" class="headerlink" title="1.4 数据工程师"></a>1.4 数据工程师</h3><p><img src="https://image.woshipm.com/wp-files/2020/02/Y7QB9rKsrRpviujuW6Qb.png"></p>
<p>数据工程师概览图</p>
<p>数据工程师的职能更偏向技术工程，主要的工作职责是搭建数据仓库、创建ETL、进行数据治理、数据安全等方面的工作、通过提升运行速度，优化数据结构，更好地服务于数据使用方，比如数据分析师、数据产品及数据建模师。</p>
<p><strong>1.4.1 成长路线：</strong> CTO、技术总监、资深研发工程师</p>
<p><strong>1.4.2 必备能力</strong></p>
<ul>
<li>① 数据技术</li>
<li>④ 建模能力</li>
<li>⑤ 业务思维能力</li>
<li>⑦ 专业能力</li>
</ul>
<p>（①④⑤⑦是啥？下文详解）</p>
<p><strong>1.4.3 成长建议</strong></p>
<p><strong>（1）我们不生产数据，只是数据的搬运工，搬好了是我们应该的，但搬不好任务流程挂掉，BI报表自动化任务失败就要扣薪水</strong></p>
<p>这是许多数据工程师接触都遇到的问题，这个时候就考验专业能力，如何优化流程，监控及预警就尤为重要了。</p>
<p>举个我自己的亲身经历吧，之前做了流失用户自动召回系统，每天定时按照算法算出目标用户并发送短信、push和红包。</p>
<p>逻辑简单的说是这样的，A表是全量用户表，B表是活跃用户，那么A-B&#x3D;C，C表就是目标用户，即不活跃的流失用户。</p>
<p>突然有一天因为一个BUG，导致B表挂掉了，B表变为空表，那么A-B&#x3D;A-0&#x3D;A&#x3D;C，就相当于把A表全量用户都发送优惠券及信息。</p>
<p>这事故仅次于PDD那次红包事故了，当时我们没有推卸责任（毕竟绩效已经没了），迅速制定了数据异常预警，人工短信确认等机制，避免了类似事故发生。</p>
<p>这次事故给我的教训就是，人无远虑必有近忧，错误是不可避免的，但如何提升专业水平，降低错误发生概率，提前预知错误，以避免资源的浪费。</p>
<p><strong>（2）沟通、沟通还是沟通…</strong></p>
<h3 id="1-5-数据科学家"><a href="#1-5-数据科学家" class="headerlink" title="1.5 数据科学家"></a>1.5 数据科学家</h3><p><img src="https://image.woshipm.com/wp-files/2020/02/vIthzhIoPvbeD0xdSVl7.png"></p>
<p>数据科学家概览图</p>
<p>综合性人才，数据分析能力、统计学基础、业务能力、算法与沟通能力集聚一身的人才。市面上有很多不懂技术只会嘴炮的领导，也不缺不懂结合业务的技术大拿，但做到样样精通，实属不易。向下能够了解前沿技术并指导下属进行研究开发，向上能够很好的与领导沟通，让领导理解这么做的价值。</p>
<ul>
<li>跟数据分析师比分析能力，数据分析师卒；</li>
<li>跟算法工程师过算法能力，算法工程师卒；</li>
<li>跟数据工程师拼技术能力，数据工程师卒；</li>
<li>跟数据产品唠业务能力，数据产品卒。</li>
</ul>
<p>就是这么强大，不过这类人才乃是可遇不可求，正所谓流氓会武术，谁也挡不住；科学家会武术，流氓也挡不住，实在是社会…社会…</p>
<p><strong>1.5.1 成长路线：</strong> 没啥可建议的，挺好的哥…</p>
<p><strong>1.5.2 必备能力：</strong> 全部①-⑧</p>
<p>（①②③④⑤⑥⑦⑧是啥？下文详解）</p>
<p><strong>1.5.3 成长建议：</strong> 没啥建议，都挺好的，就是建议给别人留条活路，卒。</p>
<h1 id="二、数据分析师的8种能力"><a href="#二、数据分析师的8种能力" class="headerlink" title="二、数据分析师的8种能力"></a>二、数据分析师的8种能力</h1><hr>
<h3 id="2-1-数据技术"><a href="#2-1-数据技术" class="headerlink" title="2.1 数据技术"></a>2.1 数据技术</h3><p>既然是数据分析，就要了解数据在各个环节是如何运转的，同时还能运用工具读取和分析数据，在这里我将其分成基础、数据提取、分析工具。</p>
<p><strong>基础：office软件</strong></p>
<p>包括且不限于excel、VBA、ppt、word，尤其是excel很深很深，大多数人只用了excel中1%的功能，到现在我只敢说会用excel，谈不上精通，也许我只用了2%吧，但应付日常数据足矣。</p>
<p><strong>数据提取：SQL、HiveSQL</strong></p>
<p>都是类SQL软件，会一个就能精通所有，大家不要觉得编程很难就望而却步，其实SQL是最简单的语言，不夸张的说，用心学SQL不到一个月就可以干活了，什么你还学不会？你只是缺个人逼你而已。</p>
<p><strong>分析工具：SPSS、SPSS modeler、R、Python、SAS</strong></p>
<p>不是每个人都有机会接触SAS，如果没机会也不要紧，这里推荐大家一定要学SPSS，可以理解为升级版的excel，也很简单；然后Python和R任选其一即可。</p>
<h3 id="2-2-可视化"><a href="#2-2-可视化" class="headerlink" title="2.2 可视化"></a>2.2 可视化</h3><p>Excel、PPT、Tableau、Echarts、powerBI</p>
<p>数据可视化的工具很多，除了Python、R、JAVA这类的之外，上面列的几种算是比较常见的BI可视化工具。先说Excel和PPT，没错它们也算可视化软件，如下图：</p>
<p><img src="https://image.woshipm.com/wp-files/2020/02/ViEc2GTTrYmf1NNICDf0.png"></p>
<p>Excel可视化</p>
<p>这是用我用excel做出来的dashboard（看板），也还可以吧，应付一般老板那是够够的。但要想玩的洋一点，就得用例如tableau、powerBI等软件，毕竟老美都用tableau么，样式如下图所示：</p>
<p><img src="https://image.woshipm.com/wp-files/2020/02/m3tgXqGfXJYIjFhILKSg.png"></p>
<p>新增用户热力图</p>
<p>不管是用什么工具，能够将抽象的数据用图形展示出来，便于老板观察和决策，那就是ok的，至于如何做的好看，那就是进阶的课题了。</p>
<h3 id="2-3-统计学基础"><a href="#2-3-统计学基础" class="headerlink" title="2.3 统计学基础"></a>2.3 统计学基础</h3><p><strong>统计学基础在AB test、数学模型、抽样检验里常常会用到</strong>，有的时候你看到的数据并不是真实的，怎么去解释，我给大家列几个例子：</p>
<p><strong>示例一 AB test的错觉：</strong></p>
<p><img src="https://image.woshipm.com/wp-files/2020/02/vhbCVMzF5sAVdsr1FE79.png"></p>
<p>AB test结果图</p>
<p>看到这张图，很多人都会认为B比A的转化效果好对吧，但是这里有多大的可能是因为一些随机的因素导致这样的区别呢，这就要用到统计学的假设检验了。</p>
<p>我们来假设B不会比A效果好，然后试图通过样本来推翻这个假设，如果样本足以推翻假设，那么我们就可以认为实验完成了，所见即所得；否则我们会认为B比A好只是偶然现象，这组AB test没有任何意义，需重新测试。</p>
<p><strong>示例二 R平方值的重要性：</strong></p>
<p><img src="https://image.woshipm.com/wp-files/2020/02/23MuaXsTiv1DZT7O2FmQ.png"></p>
<p>DAU预测图</p>
<p>上图是一个简单的回归模型用来预测DAU，<strong>红色是指数回归，绿色是多项式回归，哪种模型更精准呢，这时候就要看R方。</strong></p>
<p>R平方值是趋势线拟合程度的指标，取值范围在0到1之间，它的数值大小可以反映趋势线的估计值与对应的实际数据之间的拟合程度，拟合程度越接近1，趋势线的可靠性就越高。</p>
<p>同样是预测，3个月后指数预测比多项式预测高出30%，选哪个模型才能使误差率最小化呢，这个时候R方的重要性就体现出来了。</p>
<p>以上列举了2个统计学的小例子，在实际工作当中还会遇到很多统计学的知识，<strong>比如显著性、置信度、离散度等等，统计学会让我们的分析结果更加专业，更加严谨。</strong></p>
<h3 id="2-4-建模能力"><a href="#2-4-建模能力" class="headerlink" title="2.4 建模能力"></a>2.4 建模能力</h3><p>根据不同的业务需求，会使用一些模型，下面简单的介绍集中常用模型供大家参考。</p>
<p><strong>分类：</strong> 基于历史用户行为构建模型，套用到新用户身上，预测用户可能发生某种行为的概率，常用的分类模型有C5.0、决策树、随机森林、逻辑回归等，如下图运用逻辑回归，预测用户是否下单：</p>
<p><img src="https://image.woshipm.com/wp-files/2020/02/hf8mNrRxwmah8yxHECbP.png"></p>
<p>模型概念图</p>
<p><strong>聚类：</strong> 按照个体的特征将他们分类，让同一个类别内的个体之间具有较高的相似度，不同类别之间具有较大的差异性，常用于给用户打标签，如下图K-means聚类所示：</p>
<p><img src="https://image.woshipm.com/wp-files/2020/02/ZCGej1qGg3bmDqtzpdNt.png"></p>
<p>聚类概念图</p>
<p><strong>回归：</strong> 在③提到的指数回归和多项式回归就是典型的例子，常用于预测销量、人口等数据。</p>
<p><strong>评估：</strong> 评估模型市面上分为2大类，回归和标准化模型，多用于对品牌投放、效果投放、会员积分的评估，如下图所示：</p>
<p><img src="https://image.woshipm.com/wp-files/2020/02/hFD0wnBoExXLzOuuMukN.png"></p>
<p>渠道评估模型（AHP标准化模型）</p>
<p>除了上述的4大类模型外，还有很多种类的模型，根据实际业务去选择对应的模型就ok了，在这里不过多赘述。</p>
<h3 id="2-5-业务思维能力"><a href="#2-5-业务思维能力" class="headerlink" title="2.5 业务思维能力"></a>2.5 业务思维能力</h3><p>数据是冰冷的，若想开启真相的大门，业务思维便是我们的钥匙。</p>
<p>举个简单的例子，老板发现2019年6月份的汽车成交量突然猛增，想让你分析一下原因。</p>
<p>这时候你会发现产品、渠道、技术等等都没问题，那会是什么原因呢？</p>
<p>如果你没有业务思维就会埋在一堆数据里，如果有业务思维就会去想，国家规定2019年7月1日开始执行国六排放标准，国五汽车将不能再办理牌照，这时候经销商、4s店应该怎么办？那当然是降价清库存啦，你降价了用户当然是买买买啦。所以说业务思维非常重要，不要死看数，看死数。</p>
<h3 id="2-6-大局能力"><a href="#2-6-大局能力" class="headerlink" title="2.6 大局能力"></a>2.6 大局能力</h3><p>知己知彼，百战不殆。作为分析师亦是如此，知己好做，知彼怎么做呢？</p>
<p>那就是竞品分析，从竞品数据及竞品策略层面分析对手。</p>
<p>职场上老板也经常会问咱们的数据怎么样？</p>
<p>然后你会说大幅增长，形势一片大好。</p>
<p>老板又问了，竞品数据怎么样？</p>
<p>这时候你就傻眼了，不是回答不上来，就是数据没有竞品好看。</p>
<p>优秀的数据分析师则会这样去说：</p>
<blockquote>
<p>“我们同比增长XX，环比XX，竞品的数据是XX，我们哪些方面优秀，哪些不足，接下来应该如何如何。”</p>
</blockquote>
<p>这样一套操作下来，领导会觉得你的工作做到位了，不是一问三不知，也不是自己“闭门造车”。</p>
<h3 id="2-7-专业能力"><a href="#2-7-专业能力" class="headerlink" title="2.7 专业能力"></a>2.7 专业能力</h3><p>数据产品如何构建埋点，数据分析师如何输出有价值的商业洞悉报告，数据工程师如何优化数据结构，数据建模型如何针对不同业务建立最优模型，数据科学家如何把大数据中的规律传达给BOSS从而影响产品，流程和决策。</p>
<h3 id="2-8-沟通能力"><a href="#2-8-沟通能力" class="headerlink" title="2.8 沟通能力"></a>2.8 沟通能力</h3><p>我在面试的时候问的最多的问题是，你觉得数据分析师最重要的技能是什么？</p>
<p>对！是沟通，什么数据敏感度、增长思维、方法论都是瞎扯，你连话都听不清楚，说不明白，你能知道老板想要的是什么，你又怎么能把分析出来的价值让老板知道，所以说排名第一位的能力是沟通！沟通！沟通！</p>
<h1 id="数据分析初学者的常见问题"><a href="#数据分析初学者的常见问题" class="headerlink" title="数据分析初学者的常见问题"></a>数据分析初学者的常见问题</h1><p>日积月累，也让我形成了一套自己的认知体系，对<strong>数据分析</strong>有了一定程度的认识。在我的经历中，经常会有一些伙伴问以下两种问题：</p>
<h3 id="1、小白类"><a href="#1、小白类" class="headerlink" title="1、小白类"></a><strong>1、小白类</strong></h3><ul>
<li>我要想入行数据分析，应该从哪里开始学？</li>
<li>想成为数据分析师，我要学习那些技能、掌握那些工具？</li>
<li>我没做过数据分析，数学特别不好，能学好吗？</li>
<li>我学的是文科专业，能从事数据分析师吗？</li>
</ul>
<h3 id="2、迷茫类"><a href="#2、迷茫类" class="headerlink" title="2、迷茫类"></a>2、迷茫类</h3><ul>
<li>做了好几年数据分析，感觉看不到以后的晋升线路？</li>
<li>我对数据分析有一定了解，如何快速用到我现在的职业上</li>
<li>从事运营、产品的工作，看过和做过一些数据分析，但不专业，能不能成为专业分析师</li>
<li>以后数据分析师会不会发展不好，未来潜力如何？</li>
</ul>
<p>但无论是小白类还是迷茫类，我们都要清楚的认识到<strong>数据分析师到底是干什么的</strong>，在职场中他们到底有什么不同，只有了解了这些，以上的疑惑才能迎刃而解，我们常用的分析思维就是拆分，就好比乐高一样，有很多小积木组合，只要我们理解了这些小积木的形状，我们也就能搭建起自己的梦想。</p>
<h1 id="数据分析师类型划分"><a href="#数据分析师类型划分" class="headerlink" title="数据分析师类型划分"></a>数据分析师类型划分</h1><p>常见的几个数据分析师划分主要包含以下这6大类，当然每一类其实也有自己的层级，我只是做一个简单的区分，让大家有一个基本的概况：</p>
<p><img src="https://www.fanruan.com/bw/wp-content/uploads/2020/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%88%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%921.jpg"></p>
<h3 id="1、A类：商业分析师"><a href="#1、A类：商业分析师" class="headerlink" title="1、A类：商业分析师"></a><strong>1、A类：商业分析师</strong></h3><p><strong>1）特点：</strong> 上手快、深入难</p>
<p> <strong>2）主要的工作：</strong> 帮助业务、市场以及管理层做一些数据的洞察，还原数据的本质，讲述数据的故事，要很清楚的了解市场要什么？用户爱什么？</p>
<p> <strong>3）需要掌握的：</strong></p>
<ul>
<li>硬性技能：SQL、EXCEL、PPT</li>
<li>软性技能：表达能力、视觉思维、逻辑性强、思维清晰，特别是沟通能力！</li>
<li>掌握的方法论：ABtest、AAARRR、SWOT、RFM、28原则、5W2H等</li>
<li>掌握的统计学：常规统计指标（均值、中位数、分位数、T检验等)、回归、聚类、因子、决策树、逻辑回归等，这些足够了</li>
<li>加分项：图表可视化、结构化思维、金字塔原理、千万级数据处理经验（这类一般1年遇不到几次）</li>
</ul>
<p> <strong>4）适合人群：</strong> 文科类、运营\产品转岗类、不喜欢编程、不善于研究算法的同学</p>
<p><strong>5）以后发展：</strong> 业务负责人、独立咨询师、管理层、战略分析师、团队领头羊</p>
<p><strong>6）核心：</strong> 不一定技术强、算法掌握牛，但一定要能深入行业、深入场景</p>
<p> <strong>注意：</strong> 掌握一些宏观数据的获取方式，没事的时候多收集一些，自己根据所在行业而定，从事互联网或者移动互联网的话，最好掌握一种<a href="https://www.finebi.com/solutions/dp"><strong>自助式BI工具</strong></a>，比如Google Analytics、FineBI等。</p>
<h3 id="2、B类：炮灰分析师"><a href="#2、B类：炮灰分析师" class="headerlink" title="2、B类：炮灰分析师"></a><strong>2、B类：炮灰分析师</strong></h3><p><strong>1）特点：</strong> 啥都要学，最累、干的你怀疑数据分析的价值</p>
<p><strong>2）主要的工作：</strong> 协助业务或者上级完成一些常规的需求，这类一般是别人要什么，我们做什么，但是在不同的行业，不同的部门做的事情差异还是很大</p>
<p><strong>3）需要掌握的：</strong></p>
<ul>
<li>硬性技能：SQL、EXCEL、PPT、python\spss\R任选其一，根据场景而定</li>
<li>软性技能：沟通能力、抗打击能力、加班能力、数据管理能力（数据库和数据字典）</li>
<li>掌握的方法论：ABtest、AAARRR、SWOT、RFM、5W2等，不知道也能干</li>
<li>掌握的统计学：常规统计指标（均值、中位数、分位数等)、回归、聚类、因子、决策树、逻辑回归等，这些足够了，但基本高级的模型用不上，定位决定</li>
<li>加分项：听话能力、擅长各类工具的应用，能快速响应需求方的需求</li>
<li>突破：要自己根据环境主动参与一些讨论，承担一些从无到有的分析，从被动变为主动</li>
</ul>
<p><strong>4）以后发展：</strong> 纯正数据分析师、数据产品经理、数仓人员</p>
<p><strong>5）适合人群：</strong> 都可</p>
<h3 id="3、C类：数据分析师"><a href="#3、C类：数据分析师" class="headerlink" title="3、C类：数据分析师"></a>3、C类：数据分析师</h3><p><strong>1）特点：</strong> 独当一面、战斗力极强、对企业决策者有一定的影响</p>
<p><strong>2）主要的工作：</strong> 除了被动的常规分析外，还要能主动发现业务存在的问题，会用数据找事，梳理业务发展与指标体系之间的关系，从日常监督分析开始，更多的是专题性的分析，无中生有</p>
<p><strong>3）需要掌握的：</strong></p>
<ul>
<li>硬性技能：SQL、EXCEL、PPT、python\spss\R任选其一，tableau\FineBI\powerbi，也要懂一些市面上流行的数据产品</li>
<li>软性技能：沟通能力、表达能力、逻辑思维强</li>
<li>掌握的方法论：ABtest、AAARRR、SWOT、RFM、28原则、5W2H，用户及产品生命周期等</li>
<li>掌握的统计学：常规统计指标（均值、中位数、分位数等)、回归、聚类、因子、决策树、逻辑回归、机器学习等，这些足够用了</li>
<li>加分项：图表可视化、PPT展示、系统性思维、在行业有很多认识和沉淀</li>
<li>要点：算法、技术、工具、业务混为一体，样样都要懂</li>
<li>总结：这类目前市场上很紧缺，被称为稀缺动物</li>
</ul>
<h3 id="4、D类：BI工程师-分析师中的程序员"><a href="#4、D类：BI工程师-分析师中的程序员" class="headerlink" title="4、D类：BI工程师-分析师中的程序员"></a>4、D类：BI工程师-分析师中的程序员</h3><p><strong>1）主要的工作：</strong> 和数据的ETL打交道多，主要做数据规范、数据仓库、业务需求报表开发、多维度呈现等</p>
<p><strong>2）需要掌握的：</strong></p>
<ul>
<li>硬性技能：数据库技术、数据仓库、Informatica, Datastage，Kettle，还有一些厂家的展示产品Business Objects, Cognos，常用梳理工具</li>
<li>ERwin、echarts等</li>
<li>软性技能：理解能力、表达能力、思维缜密</li>
<li>掌握的方法论：无，基本人家让干啥咱干啥</li>
<li>掌握的统计学：常规统计指标（均值、中位数、分位数等)、回归、聚类、因子、决策树、逻辑回归等，</li>
<li>加分项：技术过硬，有过大型BI建设经验，既能干DBA又能干BI、视觉思维</li>
<li>突破：这些人比一般的数据分析师更懂底层，缺少的只是与业务的融合，看自己的定位了</li>
<li>总结：绝对的苦逼，容易吐血那种，常常怀疑人生</li>
</ul>
<p><strong>3）发展线路：</strong> CTO、项目经理、产品经理、平台负责人等</p>
<h3 id="5、E类：算法工程师-就是你们班技术最强的"><a href="#5、E类：算法工程师-就是你们班技术最强的" class="headerlink" title="5、E类：算法工程师-就是你们班技术最强的"></a>5、E类：算法工程师-就是你们班技术最强的</h3><p><strong>1）主要的工作：</strong> 做算法、搞研发、创新算法</p>
<p><strong>2）需要掌握的：</strong></p>
<ul>
<li>硬性技能：数据库技术、hadoop、python、R、spark等等</li>
<li>软性技能：理解能力、表达能力、思维能力</li>
<li>掌握的方法论：懂一些常见的即可</li>
<li>掌握的统计学：各种算法都要精通，而且在不同的场景下，要自己开发新算法</li>
<li>加分项：算法很熟悉、技术没得说、学历高</li>
<li>总结：工资高、压力大，经常断片</li>
</ul>
<p><strong>3）适合人群：</strong> 名校对口专业毕业，没办法人太多，某宝从国内top已经要求全球TOP了</p>
<h1 id="数据分析行业必备能力"><a href="#数据分析行业必备能力" class="headerlink" title="数据分析行业必备能力"></a>数据分析行业必备能力</h1><p>了解了这些数据分析师的百态之后，该如何入门的问题相信也会得到解答，我们一起来探讨一下<strong>数据分析师所需要掌握的那些能力</strong>，我总结出了以下7点和大家分享。</p>
<p><img src="https://www.finebi.com/wp-content/uploads/2020/11/8f29d7bf2723e340afeaff9bff6420e4.png"></p>
<h3 id="1、基本工具应用的能力"><a href="#1、基本工具应用的能力" class="headerlink" title="1、基本工具应用的能力"></a>1、基本工具应用的能力</h3><p>Office的三件套是必备的，特别是（excel、PPT），但所有的excel、ppt功能都要学习吗？显然不是，很多人在这个上面浪费的时间太多太多了。</p>
<ul>
<li>对于<strong>excel</strong>来讲，基本的函数（加减乘除、条件筛选、匹配函数、透视表、图表）就足够了，VBA对基础业务人员来说可以放弃。</li>
<li>对<strong>PPT</strong>来讲，不要把自己打造成为一个专业的PPTer，PPT对于分析师来讲，唯一的核心就是展示，因此基本的操作就足够了，可能当入门的时候，你连打开PPT 的机会都没有，就是提数</li>
</ul>
<h3 id="2、专业工具使用"><a href="#2、专业工具使用" class="headerlink" title="2、专业工具使用"></a>2、专业工具使用</h3><p>这一块能力主要分为2个方面，<strong>数据分析与处理和数据展示</strong>。</p>
<p>比如不善于编程的同学可以选择spss、clementine，也可以尝试玩玩kettle，不讨厌编程的话建议直接去学习python、R。</p>
<p>相对来讲，专业对口的学起来用起来顺手一些，学哪个工具都可以，一般的招聘都是掌握一种就可以，所以不要逼着自己去学不顺手的工具，浪费时间，<strong>投入产出比太低</strong>。</p>
<p>另外就是可视化的，其实excel就是一个最基础的可视化工具，简单易用，场景多，如果想要可视化分析效率更高，建议掌握tableau、<a href="https://www.finebi.com/product"><strong>FineBI</strong></a>之类的一种BI工具，现在很多企业都在用商用BI软件了，如果可以提前知道要去的企业应用的哪种，可以重点学习一下。</p>
<h3 id="3、发现问题的能力"><a href="#3、发现问题的能力" class="headerlink" title="3、发现问题的能力"></a>3、发现问题的能力</h3><p>这是一种很重要的能力，可以塑造自己从被动转为主动，这需要我们有足够的<strong>知识储备和业务的沉淀</strong>，你才有发现问题的资本，而不是让人家觉得你在找茬。</p>
<h3 id="4、解决问题的能力"><a href="#4、解决问题的能力" class="headerlink" title="4、解决问题的能力"></a>4、解决问题的能力</h3><p>数据分析不但要展示过去、现状、未来，更重要的是遇见问题的时候能告诉大家为什么会发生、为什么是这样，而不是凭我们经验去想当然地下结论。</p>
<h3 id="5、行业洞察能力"><a href="#5、行业洞察能力" class="headerlink" title="5、行业洞察能力"></a>5、行业洞察能力</h3><p>行业的洞察力不是靠阅读文章的数量，看书多少本来决定的，虽然之前存在一定的关系，但不是纯正相关或者因果关系，而是要依靠咨询公司的那一套方法论去不断的模仿、思考、复盘的。</p>
<h3 id="6、创新的对应方案"><a href="#6、创新的对应方案" class="headerlink" title="6、创新的对应方案"></a>6、创新的对应方案</h3><p>知道了事情的来龙去脉，能不能站在用户体验的角度设计出一套，记住自己分析数据、呈现数据的时候不仅仅是数据，而是一群人的行为趋势。</p>
<p>比如你要开一个陕西面馆，你<strong>能否根据用户的数据打造出一套引导改变他们习惯的面馆</strong>，而不仅仅是影响。</p>
<h3 id="7、数据的解读能力"><a href="#7、数据的解读能力" class="headerlink" title="7、数据的解读能力"></a>7、数据的解读能力</h3><p>经常看一些小伙伴写的分析报告，出现最多的就是同比、环比，而同比、环比之后在没有任何的描述，<strong>这时候你描述的只是一种数据的状态，并没有把数据背后的故事讲清楚</strong>，比如什么原因引起的？你是从哪些角度分析发现的？这样的报告很难带读者到你的思维世界</p>
<p>许多人在数据分析入门时往往<strong>忽略了<a href="https://www.finebi.com/product">数据分析</a>的本质</strong>，把太多的时间和精力放在了基本工具、专业工具方面。即使你的工具使用、编程能力不强，但只要你可迁移的能力很强，企业都会要。当然不是说大家不要投入时间去学习工具，而是建议不要投入太多的时间，比如学习excel，有的人要连续学习好几个月，其实一周足够了！</p>
<p>的趋势。</p>
<p>备受市场认可的软件其实有很多，选择时必须要结合实际的情况。一般的情况下，都建议选择市面上较主流的产品，比较容易达到好的效果，目前企业数据分析BI软件市场占有率前列的，就是帆软BI软件——<strong>FineBI</strong>。</p>
<h1 id="数据分析师所需的技术与理论"><a href="#数据分析师所需的技术与理论" class="headerlink" title="数据分析师所需的技术与理论"></a>数据分析师所需的技术与理论</h1><h3 id="1-统计学和概率论"><a href="#1-统计学和概率论" class="headerlink" title="1-统计学和概率论"></a>1-统计学和概率论</h3><p>统计学和概率论可帮助您正确理解数字、回答一些相关假设并做出更好的预测。例如：</p>
<p>销售旺季的平均销量？</p>
<p>每天售出单量增长幅度是多少？</p>
<p>还有多少潜在客户准备购买的？</p>
<p>多少个咨询客户才能转化成一个下单客户？</p>
<p>购买我们产品的客户占整个市场的百分比是多少？</p>
<p>此外，还可以使用回归和时间序列等统计方法，对未来的预期销售额做出相关预测。</p>
<h3 id="2-数据库知识"><a href="#2-数据库知识" class="headerlink" title="2-数据库知识"></a>2-数据库知识</h3><p>在大数据时代，企业的数据都是存储在数据库中的，因此至少要熟练掌握一个或以上的数据库管理系统。市场上有许多数据库管理系统，如 Oracle、MongoDB、SQLite等。但是最常用的还是MySQL，它是评价最高的开源 DBMS，以其成熟度和可靠性而闻名。但我们如何从数据库中提取所需的数据呢？这正是SQL可以发挥作用的地方，SQL是一种专门设计用于处理大型数据库的结构化语言，检索数据效率非常高。</p>
<h3 id="3-统计工具"><a href="#3-统计工具" class="headerlink" title="3-统计工具"></a>3-统计工具</h3><p>获得数据后，您需要知道至少一种统计工具，并利用这些统计工具对数据进行分析，常见的统计软件包括SPSS、SAS、Sage、Mathematica等。目前，任何人都可以使用Microsoft Excel进行最简单的统计分析，MS Excel 是一种电子表格，可帮助人们分析和绘制数据，它还可以执行大量复杂的数学和统计功能。</p>
<h3 id="4-编程语言"><a href="#4-编程语言" class="headerlink" title="4-编程语言"></a>4-编程语言</h3><p>数据分析师最常用的编程语言是 Python 和 R，原因是今天生成的数据量很大，需要掌握这些编程工具才能更好地开展工作。编程语言提供了两个主要好处。首先，它可以使数据转换变得非常容易。其次，这些语言拥有丰富的库，可以帮助人们轻松地制作预测模型，例如python 中的sklearn 库。</p>
<h3 id="5-可视化"><a href="#5-可视化" class="headerlink" title="5-可视化"></a>5-可视化</h3><p>在21世纪之后，每个行业的数据都可以被可视化，它是决策者和数据分析师了解事情结果的桥梁。目前，市场上最突出的可视化工具包括 – PowerBI、Tableau 和智分析等，以下图的智分析为例，目前的图表可视化正从传统的静态报表逐渐向BI动态报表过渡，可视化能力得到进一步的加强。</p>
<h1 id="数据分析师所需的软技能"><a href="#数据分析师所需的软技能" class="headerlink" title="数据分析师所需的软技能"></a>数据分析师所需的软技能</h1><h3 id="1-沟通"><a href="#1-沟通" class="headerlink" title="1-沟通"></a>1-沟通</h3><h3 id="2-批判性思维"><a href="#2-批判性思维" class="headerlink" title="2-批判性思维"></a>2-批判性思维</h3><h3 id="3-好奇心"><a href="#3-好奇心" class="headerlink" title="3-好奇心"></a>3-好奇心</h3><h3 id="4-解决问题"><a href="#4-解决问题" class="headerlink" title="4-解决问题"></a>4-解决问题</h3><h3 id="5-终身学习"><a href="#5-终身学习" class="headerlink" title="5-终身学习"></a>5-终身学习</h3>]]></content>
      <categories>
        <category>数据分析</category>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数据分析师</tag>
        <tag>方法论</tag>
      </tags>
  </entry>
  <entry>
    <title>这可能是我见过最好的 NumPy 图解教程！</title>
    <url>/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>NumPy是Python中用于数据分析、机器学习、科学计算的重要软件包。它极大地简化了向量和矩阵的操作及处理。python的不少数据处理软件包依赖于NumPy作为其基础架构的核心部分（例如scikit-learn、SciPy、pandas和tensorflow）。除了数据切片和数据切块的功能之外，掌握numpy也使得开发者在使用各数据处理库调试和处理复杂用例时更具优势。</p>
</blockquote>
<p><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0001.png"></p>
<p>在本文中，将介绍NumPy的主要用法，以及它如何呈现不同类型的数据（表格，图像，文本等），这些经Numpy处理后的数据将成为机器学习模型的输入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>

<h1 id="NumPy中的数组操作"><a href="#NumPy中的数组操作" class="headerlink" title="NumPy中的数组操作"></a>NumPy中的数组操作</h1><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>我们可以通过将python列表传入np.array()来创建一个NumPy数组（也就是强大的ndarray）。在下面的例子里，创建出的数组如右边所示，<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0002.png"></p>
<p>通常情况下，我们希望NumPy为我们初始化数组的值，为此NumPy提供了诸如ones()，zeros()和random.random()之类的方法。我们只需传入元素个数即可：</p>
<p><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0003.png"><br>一旦我们创建了数组，我们就可以用其做点有趣的应用了，文摘菌将在下文展开说明。</p>
<h3 id="数组的算术运算"><a href="#数组的算术运算" class="headerlink" title="数组的算术运算"></a>数组的算术运算</h3><p>让我们创建两个NumPy数组，分别称作data和ones：</p>
<p><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0004.png"><br>若要计算两个数组的加法，只需简单地敲入data + ones，就可以实现对应位置上的数据相加的操作（即每行数据进行相加），这种操作比循环读取数组的方法代码实现更加简洁。<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0005.png"></p>
<p>当然，在此基础上举一反三，也可以实现减法、乘法和除法等操作：<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0006.png"><br>许多情况下，我们希望进行数组和单个数值的操作（也称作向量和标量之间的操作）。比如：如果数组表示的是以英里为单位的距离，我们的目标是将其转换为公里数。可以简单的写作<code>data \* 1.6</code>：<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0007.png"></p>
<p>NumPy通过数组广播（broadcasting）知道这种操作需要和数组的每个元素相乘。</p>
<h3 id="数组的切片操作"><a href="#数组的切片操作" class="headerlink" title="数组的切片操作"></a>数组的切片操作</h3><p>我们可以像python列表操作那样对NumPy数组进行索引和切片，如下图所示：  </p>
<p><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0008.png"></p>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>NumPy为我们带来的便利还有聚合函数，聚合函数可以将数据进行压缩，统计数组中的一些特征值：<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0009.png"></p>
<p>除了<code>min</code>，<code>max</code>和<code>sum</code>等函数，还有<code>mean（均值）</code>，<code>prod（数据乘法）</code>计算所有元素的乘积，std（标准差），等等。上面的所有例子都在一个维度上处理向量。除此之外，NumPy之美的一个关键之处是它能够将之前所看到的所有函数应用到任意维度上。</p>
<h1 id="NumPy中的矩阵操作"><a href="#NumPy中的矩阵操作" class="headerlink" title="NumPy中的矩阵操作"></a>NumPy中的矩阵操作</h1><h3 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a>创建矩阵</h3><p>我们可以通过将二维列表传给Numpy来创建矩阵。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br></pre></td></tr></table></figure>

<p><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0010.png"><br>除此外，也可以使用上文提到的<code>ones()</code>、<code>zeros()</code>和<code>random.random()</code>来创建矩阵，只需传入一个元组来描述矩阵的维度：  </p>
<p><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0011.png"></p>
<h3 id="矩阵的算术运算"><a href="#矩阵的算术运算" class="headerlink" title="矩阵的算术运算"></a>矩阵的算术运算</h3><p>对于大小相同的两个矩阵，我们可以使用算术运算符（<code>+-\*/</code>）将其相加或者相乘。NumPy对这类运算采用对应位置（position-wise）操作处理：  </p>
<p><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0012.png"><br>对于不同大小的矩阵，只有两个矩阵的维度同为1时（例如矩阵只有一列或一行），我们才能进行这些算术运算，在这种情况下，NumPy使用广播规则（broadcast）进行操作处理：<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0013.png"><br>与算术运算有很大区别是使用点积的矩阵乘法。NumPy提供了<code>dot()</code>方法，可用于矩阵之间进行点积运算：<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0014.png"></p>
<p>上图的底部添加了矩阵尺寸，以强调运算的两个矩阵在列和行必须相等。可以将此操作图解为如下所示：<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0015.png"></p>
<h3 id="矩阵的切片和聚合"><a href="#矩阵的切片和聚合" class="headerlink" title="矩阵的切片和聚合"></a>矩阵的切片和聚合</h3><p>索引和切片功能在操作矩阵时变得更加有用。可以在不同维度上使用索引操作来对数据进行切片。  </p>
<p><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0016.png"></p>
<p>我们可以像聚合向量一样聚合矩阵：</p>
<p><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0017.png"></p>
<p>不仅可以聚合矩阵中的所有值，还可以使用<code>axis</code>参数指定行和列的聚合：</p>
<p><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0018.png"></p>
<h3 id="矩阵的转置和重构"><a href="#矩阵的转置和重构" class="headerlink" title="矩阵的转置和重构"></a>矩阵的转置和重构</h3><p>处理矩阵时经常需要对矩阵进行转置操作，常见的情况如计算两个矩阵的点积。NumPy数组的属性T可用于获取矩阵的转置。</p>
<p><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0019.png"></p>
<p>在较为复杂的用例中，你可能会发现自己需要改变某个矩阵的维度。这在机器学习应用中很常见，例如模型的输入矩阵形状与数据集不同，可以使用NumPy的<code>reshape()</code>方法。只需将矩阵所需的新维度传入即可。也可以传入-1，NumPy可以根据你的矩阵推断出正确的维度：<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0020.png"></p>
<p>上文中的所有功能都适用于多维数据，其中心数据结构称为ndarray（N维数组）。</p>
<p><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0021.png"></p>
<p>很多时候，改变维度只需在NumPy函数的参数中添加一个逗号，如下图所示：</p>
<p><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0022.png"></p>
<h1 id="NumPy中的公式应用示例"><a href="#NumPy中的公式应用示例" class="headerlink" title="NumPy中的公式应用示例"></a>NumPy中的公式应用示例</h1><p>NumPy的关键用例是实现适用于矩阵和向量的数学公式。这也Python中常用NumPy的原因。例如，均方误差是监督机器学习模型处理回归问题的核心：</p>
<p><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0023.png"></p>
<p>在NumPy中可以很容易地实现均方误差：<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0024.png"></p>
<p>这样做的好处是，numpy无需考虑predictions与labels具体包含的值。文摘菌将通过一个示例来逐步执行上面代码行中的四个操作：<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0025.png"></p>
<p>预测（predictions）和标签（labels）向量都包含三个值。这意味着n的值为3。在我们执行减法后，我们最终得到如下值：<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0026.png"></p>
<p>然后我们可以计算向量中各值的平方：<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0027.png"></p>
<p>现在我们对这些值求和：<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0028.png"></p>
<p>最终得到该预测的误差值和模型质量分数。</p>
<h1 id="用NumPy表示日常数据"><a href="#用NumPy表示日常数据" class="headerlink" title="用NumPy表示日常数据"></a>用NumPy表示日常数据</h1><p>日常接触到的数据类型，如电子表格，图像，音频……等，如何表示呢？Numpy可以解决这个问题。</p>
<h3 id="表和电子表格"><a href="#表和电子表格" class="headerlink" title="表和电子表格"></a>表和电子表格</h3><p>电子表格或数据表都是二维矩阵。电子表格中的每个工作表都可以是自己的变量。python中类似的结构是pandas数据帧（dataframe），它实际上使用NumPy来构建的。<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0029.png"></p>
<h3 id="音频和时间序列"><a href="#音频和时间序列" class="headerlink" title="音频和时间序列"></a>音频和时间序列</h3><p>音频文件是一维样本数组。每个样本都是代表一小段音频信号的数字。CD质量的音频每秒可能有44,100个采样样本，每个样本是一个-65535到65536之间的整数。这意味着如果你有一个10秒的CD质量的WAVE文件，你可以将它加载到长度为10 * 44,100 &#x3D; 441,000个样本的NumPy数组中。想要提取音频的第一秒？只需将文件加载到我们称之为audio的NumPy数组中，然后截取audio[:44100]。</p>
<p>以下是一段音频文件：<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0030.png"></p>
<p>时间序列数据也是如此（例如，股票价格随时间变化的序列）。</p>
<h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h3><p>图像是大小为（高度×宽度）的像素矩阵。如果图像是黑白图像（也称为灰度图像），则每个像素可以由单个数字表示（通常在0（黑色）和255（白色）之间）。如果对图像做处理，裁剪图像的左上角10 x 10大小的一块像素区域，用NumPy中的image[:10,:10]就可以实现。</p>
<p>这是一个图像文件的片段：<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0031.png"></p>
<p>如果图像是彩色的，则每个像素由三个数字表示 ：红色，绿色和蓝色。在这种情况下，我们需要第三维（因为每个单元格只能包含一个数字）。因此彩色图像由尺寸为(高x宽x 3）的ndarray表示。<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0032.png"></p>
<h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><p>如果我们处理文本，情况就会有所不同。用数字表示文本需要两个步骤，构建词汇表（模型知道的所有唯一单词的清单）和嵌入（embedding）。让我们看看用数字表示这个（翻译的）古语引用的步骤：“Have the bards who preceded me left any theme unsung?”</p>
<p>模型需要先训练大量文本才能用数字表示这位战场诗人的诗句。我们可以让模型处理一个小数据集，并使用这个数据集来构建一个词汇表（71,290个单词）：<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0033.png"></p>
<p>然后可以将句子划分成一系列“词”token（基于通用规则的单词或单词部分）：<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0034.png"></p>
<p>然后我们用词汇表中的id替换每个单词：<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0035.png"></p>
<p>这些ID仍然不能为模型提供有价值的信息。因此，在将一系列单词送入模型之前，需要使用嵌入（embedding）来替换token&#x2F;单词（在本例子中使用50维度的word2vec嵌入)：<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0036.png"></p>
<p>你可以看到此NumPy数组的维度为[embedding_dimension x sequence_length]。</p>
<p>在实践中，这些数值不一定是这样的，但我以这种方式呈现它是为了视觉上的一致。出于性能原因，深度学习模型倾向于保留批数据大小的第一维（因为如果并行训练多个示例，则可以更快地训练模型）。很明显，这里非常适合使用reshape()。例如，像BERT这样的模型会期望其输入矩阵的形状为：[batch_size，sequence_length，embedding_size]。<br><img src="/studyz.github.io/2023/10/23/2023_10_23_%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%88%91%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84NumPy%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/0037.png"></p>
<p>这是一个数字合集，模型可以处理并执行各种有用的操作。我留空了许多行，可以用其他示例填充以供模型训练（或预测）。</p>
<p>事实证明，在我们的例子中，那位诗人的话语比其他诗人的诗句更加名垂千古。尽管生而为奴，诗人安塔拉（Antarah）的英勇和语言能力使他获得了自由和神话般的地位，他的诗是伊斯兰教以前的阿拉伯半岛《悬诗》的七首诗之一。</p>
]]></content>
      <categories>
        <category>tutorial</category>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>DATEDIFF_日期之差</title>
    <url>/studyz.github.io/2024/02/28/2024_02_28_DATEDIFF_%E6%97%A5%E6%9C%9F%E4%B9%8B%E5%B7%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>DATEDIFF是一个SQL函数，用于计算两个日期之间的差距。</p>
<p>DATEDIFF函数的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATEDIFF(datepart, startdate, enddate)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>datepart</code>参数是用于指定日期部分的字符串，表示希望计算的差距类型。常见的datepart包括：年(year)、季度(quarter)、月(month)、周(week)、天(day)、小时(hour)、分钟(minute)、秒(second)等。</li>
<li><code>startdate</code>参数是起始日期。</li>
<li><code>enddate</code>参数是结束日期。</li>
</ul>
<p>DATEDIFF函数会根据指定的datepart，计算出enddate与startdate之间的差距，并以整数形式返回差距值。</p>
<p>以下是一个示例，演示如何使用DATEDIFF函数计算两个日期之间的天数差距：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DATEDIFF(day, &#x27;2021-01-01&#x27;, &#x27;2021-01-10&#x27;) AS DayDifference;</span><br></pre></td></tr></table></figure>

<p>上述查询将返回结果为9，表示从2021年1月1日到2021年1月10日之间相差了9天。</p>
<p>请注意，DATEDIFF函数的计算结果取决于所使用的数据库管理系统，因此在具体使用时请参考相应数据库的文档。</p>
<p>希望这个解释对您有所帮助。如果您还有其他问题，请随时提问。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>GroupBy</title>
    <url>/studyz.github.io/2024/02/28/2024_02_28_GroupBy/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当我们需要对数据进行分组并进行聚合计算时，可以使用GROUP BY子句。GROUP BY子句通常与聚合函数（如SUM、COUNT、AVG等）一起使用。</p>
<p>通过GROUP BY子句，我们可以将数据按照指定的列进行分组，并对每个组进行聚合计算。这些聚合计算的结果将基于每个组的值。</p>
<p>下面是一个示例，假设我们有一个名为”orders”的表，其中包含了订单信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT product_id, COUNT(*) as total_orders</span><br><span class="line">FROM orders</span><br><span class="line">GROUP BY product_id;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们按照”product_id”列进行了分组，并计算了每个产品的订单总数。通过使用COUNT(*)函数，我们可以计算每个产品的订单数量。</p>
<p>GROUP BY子句可以与多个列一起使用，以便更细致地分组数据。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT category_id, product_id, COUNT(*) as total_orders</span><br><span class="line">FROM orders</span><br><span class="line">GROUP BY category_id, product_id;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们按照”category_id”和”product_id”两列进行了分组，并计算了每个产品在每个类别中的订单总数。</p>
<p>需要注意的是，GROUP BY子句必须与SELECT语句一起使用，并且SELECT语句中的列必须是GROUP BY子句中的列或者是聚合函数的参数。这样才能确保查询的正确性。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL学习笔记</title>
    <url>/studyz.github.io/2024/02/28/2024_02_28_SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="/_post/2024_02_28_%E6%8E%92%E5%BA%8F_DENSE_RANK.md">排序_DENSE_RANK</a></p>
<h2 id="IFNULL"><a href="#IFNULL" class="headerlink" title="IFNULL"></a>IFNULL</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"></span><br><span class="line">select e.name, b.bonus</span><br><span class="line"></span><br><span class="line">from Employee e left join Bonus b</span><br><span class="line"></span><br><span class="line">on e.empId = b.empId</span><br><span class="line"></span><br><span class="line">where ifnull(bonus,0)&lt;1000</span><br><span class="line">## ifnul 就把值替换成0）</span><br></pre></td></tr></table></figure>




<h2 id="SQL-585"><a href="#SQL-585" class="headerlink" title="SQL 585"></a>SQL 585</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016</span><br><span class="line"></span><br><span class="line">FROM Insurance</span><br><span class="line"></span><br><span class="line">WHERE tiv_2015 IN (</span><br><span class="line"></span><br><span class="line">SELECT tiv_2015</span><br><span class="line"></span><br><span class="line">FROM Insurance</span><br><span class="line"></span><br><span class="line">GROUP BY tiv_2015</span><br><span class="line"></span><br><span class="line">HAVING COUNT(*) &gt; 1</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">AND (lat, lon) NOT IN (</span><br><span class="line"></span><br><span class="line">SELECT lat, lon</span><br><span class="line"></span><br><span class="line">FROM Insurance</span><br><span class="line"></span><br><span class="line">GROUP BY lat, lon</span><br><span class="line"></span><br><span class="line">HAVING COUNT(*) &gt; 1</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h2 id="SQL-610"><a href="#SQL-610" class="headerlink" title="SQL 610"></a>SQL 610</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">select </span><br><span class="line">    *,</span><br><span class="line">    if(x+y&gt;z and x+z&gt;y and y+z&gt;x,&#x27;Yes&#x27;,&#x27;No&#x27;) as triangle</span><br><span class="line">from Triangle</span><br></pre></td></tr></table></figure>



<h2 id="SQL1633-ORDER-BY-2-DESC-1"><a href="#SQL1633-ORDER-BY-2-DESC-1" class="headerlink" title="SQL1633 ORDER BY 2 DESC, 1"></a>SQL1633 ORDER BY 2 DESC, 1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ORDER BY 2 DESC, 1</span><br></pre></td></tr></table></figure>

<p>这一行使用ORDER BY子句对结果进行排序。我们按照第二列（即percentage）的降序进行排序，如果百分比相同，则按照第一列（即contest_id）的升序进行排序。</p>
<h2 id="SQL1179-CASE-WHEN"><a href="#SQL1179-CASE-WHEN" class="headerlink" title="SQL1179 CASE WHEN"></a>SQL1179 CASE WHEN</h2><p>CASE WHEN语句是SQL中用于根据条件进行条件判断和返回不同结果的表达式。它允许你根据满足特定条件的情况，选择不同的结果进行返回。</p>
<p>CASE WHEN语句的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE</span><br><span class="line">   WHEN condition1 THEN result1</span><br><span class="line">   WHEN condition2 THEN result2</span><br><span class="line">   ...</span><br><span class="line">   ELSE resultN</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>首先，你提供一个或多个WHEN子句，每个子句后面跟着一个条件（condition）和一个对应的结果（result）。当满足某个条件时，相应的结果将被返回。ELSE子句是可选的，用于指定当没有任何条件满足时的默认结果。</p>
<p>让我们通过一个简单的例子来说明CASE WHEN的使用。假设有一个名为”students”的表，其中包含学生的姓名和分数列。如果要将成绩分为优秀、良好和及格三个等级并进行显示，可以使用以下SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT name,</span><br><span class="line">       CASE</span><br><span class="line">          WHEN score &gt;= 90 THEN &#x27;优秀&#x27;</span><br><span class="line">          WHEN score &gt;= 80 THEN &#x27;良好&#x27;</span><br><span class="line">          WHEN score &gt;= 60 THEN &#x27;及格&#x27;</span><br><span class="line">          ELSE &#x27;不及格&#x27;</span><br><span class="line">       END AS grade</span><br><span class="line">FROM students;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，对于每个学生，我们使用CASE WHEN语句根据他们的分数来判断他们的等级。如果分数大于等于90，那么他们被归类为”优秀”；如果分数大于等于80，但小于90，他们被归类为”良好”；如果分数大于等于60，但小于80，他们被归类为”及格”；否则，他们被归类为”不及格”。</p>
<p>通过使用CASE WHEN语句，我们可以根据不同的条件返回不同的结果，从而实现灵活的数据处理和转换。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL窗口函数_LEAD_LAG详解</title>
    <url>/studyz.github.io/2024/02/28/2024_02_28_SQL%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0_LEAD_LAG%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当涉及到SQL窗口函数时，LEAD()和LAG()是两个非常有用的函数。它们允许我们在查询中访问当前行之前或之后的行的值。</p>
<p>LEAD()函数返回当前行之后的指定行数的值，而LAG()函数返回当前行之前的指定行数的值。这两个函数在许多情况下都很有用，例如在分析时间序列数据或计算相邻行之间的差异时。</p>
<p>让我们以一个简单的示例来说明LEAD()和LAG()函数的用法。假设我们有一个名为sales的表，其中包含了销售数据：</p>
<p>sales表：</p>
<table>
<thead>
<tr>
<th>sale_id</th>
<th>sale_date</th>
<th>sale_amount</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2021-01-01</td>
<td>1000</td>
</tr>
<tr>
<td>2</td>
<td>2021-01-02</td>
<td>1500</td>
</tr>
<tr>
<td>3</td>
<td>2021-01-03</td>
<td>2000</td>
</tr>
<tr>
<td>4</td>
<td>2021-01-04</td>
<td>1200</td>
</tr>
<tr>
<td>5</td>
<td>2021-01-05</td>
<td>1800</td>
</tr>
</tbody></table>
<p>如果我们想要计算每天的销售额与前一天销售额的差异，我们可以使用LAG()函数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  sale_date,</span><br><span class="line">  sale_amount,</span><br><span class="line">  <span class="built_in">LAG</span>(sale_amount) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_date) <span class="keyword">AS</span> previous_day_sale_amount,</span><br><span class="line">  sale_amount <span class="operator">-</span> <span class="built_in">LAG</span>(sale_amount) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_date) <span class="keyword">AS</span> difference</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  sales;</span><br></pre></td></tr></table></figure>

<p>上述查询中，我们使用了LAG()函数来获取前一天的销售额，并通过与当前销售额的差异计算了difference列的值。通过指定ORDER BY子句，我们可以按照日期的顺序进行计算。</p>
<p>类似地，如果我们想要计算每天的销售额与后一天销售额的差异，我们可以使用LEAD()函数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  sale_date,</span><br><span class="line">  sale_amount,</span><br><span class="line">  <span class="built_in">LEAD</span>(sale_amount) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_date) <span class="keyword">AS</span> next_day_sale_amount,</span><br><span class="line">  <span class="built_in">LEAD</span>(sale_amount) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_date) <span class="operator">-</span> sale_amount <span class="keyword">AS</span> difference</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  sales;</span><br></pre></td></tr></table></figure>

<p>这次，我们使用了LEAD()函数来获取后一天的销售额，并计算了差异。</p>
<p>LEAD()和LAG()函数还支持更复杂的用法，比如指定分区（PARTITION BY）来在不同的组中进行计算，以及指定默认值以处理边界情况。它们可以极大地提升分析和比较相邻行的能力。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>排序_DENSE_RANK</title>
    <url>/studyz.github.io/2024/02/28/2024_02_28_%E6%8E%92%E5%BA%8F_DENSE_RANK/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="rank"><a href="#rank" class="headerlink" title="rank()"></a>rank()</h2><h2 id="dense-rank"><a href="#dense-rank" class="headerlink" title="dense_rank()"></a>dense_rank()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DENSE_RANK() OVER (PARTITION BY column1, column2... ORDER BY column3, column4...)</span><br></pre></td></tr></table></figure>

<ul>
<li>PARTITION BY子句是可选的，用于将数据分成不同的分组。如果不指定PARTITION BY子句，将对整个结果集进行排名。</li>
<li>ORDER BY子句指定用于排序的列。可以根据一个或多个列进行排序，以确定排名的顺序。</li>
</ul>
<h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT name, salary, DENSE_RANK() OVER (ORDER BY salary DESC) AS dense_rank</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>



<p>当使用DENSE_RANK函数和PARTITION BY子句时，以下是示例查询的可能返回结果：</p>
<p>示例1：对每个客户的订单金额进行排名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT order_id, customer_id, order_amount,</span><br><span class="line">       DENSE_RANK() OVER (PARTITION BY customer_id ORDER BY order_amount DESC) AS dense_rank</span><br><span class="line">FROM orders;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>order_id</th>
<th>customer_id</th>
<th>order_amount</th>
<th>dense_rank</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>500</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1001</td>
<td>500</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>1001</td>
<td>300</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>1002</td>
<td>700</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>1002</td>
<td>600</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>1002</td>
<td>600</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>1002</td>
<td>400</td>
<td>3</td>
</tr>
</tbody></table>
<p>在上述结果中，我们根据每个客户的订单金额进行了排名。客户ID为1001的客户有两个订单，订单金额都是500，因此它们被分配相同的密集排名1。客户ID为1001的第三个订单金额为300，所以它被分配密集排名2。对于客户ID为1002的客户，有一个订单金额为700，它被分配密集排名1，然后有两个订单金额为600，它们被分配密集排名2，最后一个订单金额为400，它被分配密集排名3。</p>
<p>示例2：对每个班级的学生成绩进行排名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT student_id, class_id, exam_score,</span><br><span class="line">       DENSE_RANK() OVER (PARTITION BY class_id ORDER BY exam_score DESC) AS dense_rank</span><br><span class="line">FROM students;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>student_id</th>
<th>class_id</th>
<th>exam_score</th>
<th>dense_rank</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>A</td>
<td>95</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>A</td>
<td>90</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>A</td>
<td>85</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>B</td>
<td>92</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>B</td>
<td>88</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>B</td>
<td>88</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>B</td>
<td>80</td>
<td>3</td>
</tr>
</tbody></table>
<p>在上述结果中，我们根据每个班级的考试成绩进行了排名。班级ID为A的学生有三个学生，分别获得了95、90和85分，他们分别被分配密集排名1、2和3。班级ID为B的学生有四个学生，分别获得了92、88、88和80分，他们分别被分配密集排名1、2、2和3。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>SQL</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>群晖NAS实现SSH免密码登录</title>
    <url>/studyz.github.io/2024/04/17/2024_04_17_%E7%BE%A4%E6%99%96NAS%E5%AE%9E%E7%8E%B0SSH%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>简介：在群晖 DS920+上传电脑端公钥，并关闭 SSH 密码登录</p>
</blockquote>
<h2 id="STEP-1-开启并登录-SSH"><a href="#STEP-1-开启并登录-SSH" class="headerlink" title="STEP 1 开启并登录 SSH"></a>STEP 1 开启并登录 SSH</h2><h3 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h3><p>群晖中，启用<code>控制面板 &gt; 终端机和 SNMP &gt; 终端机</code>中的<code>启动 SSH 功能</code> 选项，修改端口号为<code>8888</code> 或者选择其他未占用端口。</p>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>在电脑端，使用终端应用登录群晖，可以使用命令行方式登录，例如：<code>ssh -p 8888 legalgeek@192.168.1.2</code></p>
<p>也可以在 <code>~/.ssh/config</code> 配置文件中增加一个服务器设定，然后通过 <code>ssh qh</code> 快捷登录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 ~/.ssh/config 文件示例：</span>  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">服务器</span>  </span><br><span class="line">Host qh  </span><br><span class="line">	HostName your_ip  </span><br><span class="line">	Port your_port  </span><br><span class="line">	User your_username</span><br></pre></td></tr></table></figure>

<p>上面一步执行完毕，需要输入用户密码。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>使用 <code>ls -a</code>检测群晖当前用户主目录下是否有 .ssh 文件夹，如果没有使用下列命令创建：</p>
<h2 id="STEP-2-粘贴公钥"><a href="#STEP-2-粘贴公钥" class="headerlink" title="STEP 2 粘贴公钥"></a>STEP 2 粘贴公钥</h2><p>将自己电脑的公钥粘贴进群晖的<code>authorized_keys</code>，具体方法：</p>
<p>1、当前终端中，使用命令： <code>vim ~/.ssh/authorized_keys</code></p>
<p>2、然后按 <code>i</code> 进入编辑模式</p>
<p>3、<strong>新建</strong>一个终端窗口，使用 <code>cat ~/.ssh/id_rsa.pub</code>获取电脑端公钥信息，右键复制，再粘贴到上一步的编辑窗口中</p>
<p>4、按 <code>ESC</code> 后输入 <code>:wq</code> 并回车保存</p>
<h2 id="STEP-3-可选-新建公钥"><a href="#STEP-3-可选-新建公钥" class="headerlink" title="STEP 3 (可选) 新建公钥"></a>STEP 3 (可选) 新建公钥</h2><p>如果电脑端没有生成过公钥的话，需要在终端上使用 <code>ssh-keygen -t rsa -C &quot;MyName&quot;</code> 创建一个密钥。</p>
<p>然后使用 <code>cat ~/.ssh/id_rsa.pub</code>获取公钥信息</p>
<p>再粘贴到<strong>群晖</strong>的 <code>~/.ssh/authorized_keys</code> 文件中。</p>
<h2 id="STEP-4-设置权限"><a href="#STEP-4-设置权限" class="headerlink" title="STEP 4 设置权限"></a>STEP 4 设置权限</h2><p>群晖用户目录权限默认为 777，必须要修改为 755 才能免密登录</p>
<p>具体权限设置命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 755 ~  </span><br><span class="line">chmod 600 ~/.ssh/authorized_keys  </span><br><span class="line">chmod 700 ~/.ssh</span><br></pre></td></tr></table></figure>


<h2 id="STEP-5-打开公钥登录设置"><a href="#STEP-5-打开公钥登录设置" class="headerlink" title="STEP 5 打开公钥登录设置"></a>STEP 5 打开公钥登录设置</h2><p>修改 <code>sshd_config</code> 配置文件:</p>
<p><code>sudo vim /etc/ssh/sshd_config</code></p>
<p>修改上述文件中以下几个配置（去除行首的注释符号<code>#</code>即可）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PubkeyAuthentication yes  </span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<h2 id="STEP-6-重启-SSH-服务"><a href="#STEP-6-重启-SSH-服务" class="headerlink" title="STEP 6 重启 SSH 服务"></a>STEP 6 重启 SSH 服务</h2><p>在群晖<code>控制面板 -&gt; 终端机和 SNMP</code> 关闭再开启 <code>SSH</code>，即可免密登录群晖。</p>
<h2 id="STEP-7-关闭密码登录"><a href="#STEP-7-关闭密码登录" class="headerlink" title="STEP 7 关闭密码登录"></a>STEP 7 关闭密码登录</h2><p>保存好 <code>密钥对（id_rsa 和 id_rsa.pub）</code>的情况下，关闭密码登录群晖 SSH，增强安全性。</p>
<p>具体方式：</p>
<p>修改 <code>sshd_config</code> 配置文件命令：</p>
<p><code>sudo vim /etc/ssh/sshd_config</code></p>
<p>修改上述文件中以下配置：</p>
<p><code>PasswordAuthentication no</code></p>
<p>然后 重复 STEP 6 重启群晖 <code>SSH</code> 即可关闭密码登录群晖 <code>SSH</code>。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>群晖</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>群晖Git部署Hexo</title>
    <url>/studyz.github.io/2024/04/20/2024_04_20_Git_Hexo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/studyz.github.io/assets/css/APlayer.min.css"><script src="/studyz.github.io/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h2><h3 id="1-1-注册-账号-Gitee-GitHub"><a href="#1-1-注册-账号-Gitee-GitHub" class="headerlink" title="1.1 注册 账号 Gitee&#x2F;GitHub"></a>1.1 注册 账号 Gitee&#x2F;GitHub</h3><p>注册一个属于自己的 Github 或 Gitee 账号，</p>
<p>Gitee在国内访问速度更快，但Gitee需要上传身份证照片若干张进行实名认证，懒得掏身份证，pass掉。<br><img src="/studyz.github.io/2024/04/20/2024_04_20_Git_Hexo/%E5%AE%9E%E5%90%8D%E9%AA%8C%E8%AF%81.png" alt="实名认证"></p>
<p>本文采用 Github 演示。 </p>
<h3 id="1-2-安装-Git"><a href="#1-2-安装-Git" class="headerlink" title="1.2 安装 Git"></a>1.2 安装 Git</h3><p>选择对应的系统平台，下载后，傻瓜式安装即可。 安装完成后，打开运行 –&gt; 输入命令，回车打开命令行窗口 输入以下Git指令</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git <span class="comment">--version</span></span><br></pre></td></tr></table></figure>

<p>出现版本号，即代表 git 安装成功</p>
<h3 id="1-3-Git-和-Github-建立联系"><a href="#1-3-Git-和-Github-建立联系" class="headerlink" title="1.3 Git 和 Github 建立联系"></a>1.3 Git 和 Github 建立联系</h3><p>任意目录下，打开 git bash 命令行，输入以下命令生成公钥：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C 邮箱</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为了管理多个密钥，你可以在生成密钥时为每个密钥指定不同的文件名</span></span><br><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot; -f ~/.ssh/id_rsa_example_com</span><br></pre></td></tr></table></figure>


<p>回车出现 （y&#x2F;n）, 输入 y , 连续点击回车，即可生成。</p>
<p>在<code>~/.ssh</code> 目录，找到 <code>id_rsa_example_com.pub</code> 文件，<code>cat ~/.ssh/id_rsa_example_com.pub</code>获取公钥。</p>
<p>到GitHub找到 <code>设置</code> 并打开，找到左侧栏 <code>Access</code>下找到<code>SSH and GPG keys</code>，点击<code>New SSH keys</code>，添加 <code>Title</code> 和 <code>Key</code></p>
<p>云端仓库创建完成的 gitee，更改远程仓库 URL 为 SSH</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 600 ~/.ssh/id_rsa_*</span><br><span class="line">chown your_username:users ~/.ssh/id_rsa_*</span><br></pre></td></tr></table></figure>


<p><strong>输入以下指令，进行全局配置：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>查看config文件是否存在，不存在新建<code>touch config</code>,<br> config文件内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_example_com</span><br><span class="line">    PreferredAuthentications publickey</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试连接</span></span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>



<p>将纳入版本库的文件，提交到 gitee 远程仓库：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">add</span> .</span><br><span class="line">git commit -m <span class="string">&#x27;first commit&#x27;</span></span><br><span class="line">git remote <span class="built_in">add</span> origin 你的仓库地址</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>此时，提交完成，打开浏览器，输入你的仓库地址，刷新即可看到文件。</p>
<ol>
<li><code>hexo clean</code>: 这个命令用于清理缓存文件和已生成的静态文件。它删除了<code>public</code>文件夹中的内容以及<code>.hexo</code>文件夹中的缓存文件。这是在部署博客之前的一个好习惯，因为它确保了生成的静态文件是最新的，避免了由于旧的缓存或文件导致的潜在问题。</li>
<li><code>hexo deploy</code>: 这个命令用于将博客部署到服务器上。在执行这个命令之前，Hexo会生成所有的静态文件，并根据<code>_config.yml</code>文件中的<code>deploy</code>部分配置将它们上传到指定的服务器。这通常涉及到将文件推送到GitHub Pages、FTP服务器或其他静态网站托管服务。</li>
</ol>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">$ hexo clean <span class="meta">&amp;&amp; hexo deploy</span></span><br></pre></td></tr></table></figure>

<p>在NAS上定时执行<code>hexo clean &amp;&amp; hexo deploy</code>，实现自动更新内容。</p>
]]></content>
      <categories>
        <category>tutorial</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>笔记</tag>
        <tag>ssh</tag>
        <tag>tutorial</tag>
      </tags>
  </entry>
</search>
